Library "Bitwise" by "Hyper" 
{
    public long Set(long in_base, int in_offset, bool in_isOffsetBitIndex = true)
    {
        return in_base | (in_isOffsetBitIndex ? (1L << in_offset) : in_offset);
    }

    public long Reset(long in_base, int in_offset, bool in_isOffsetBitIndex = true)
    {
        return in_base & (in_isOffsetBitIndex ? ~(1L << in_offset) : in_offset);
    }

    public bool Test(long in_base, int in_offset, bool in_isOffsetBitIndex = true)
    {
        return (in_base & (in_isOffsetBitIndex ? (1L << in_offset) : in_offset)) != 0;
    }
}
Library "HMM" by "Hyper"
{
    #lib "INI"

    using System.Collections.Generic;
    using System.IO;

    public Dictionary<string, Dictionary<string, string>> GetModsDatabase()
    {
        string workingDir = Directory.GetCurrentDirectory();
        string cpkredirCfgPath = Path.Combine(workingDir, "cpkredir.ini");

        if (!File.Exists(cpkredirCfgPath))
            return new();

        var cpkredirCfg = INI.Read(cpkredirCfgPath);
        string modsDbPath = cpkredirCfg["CPKREDIR"]["ModsDbIni"];

        if (!File.Exists(modsDbPath))
            return new();

        return INI.Read(modsDbPath);
    }

    public List<Mod> GetMods()
    {
        List<Mod> result = new();

        var modsDb = GetModsDatabase();

        if (modsDb == null)
            return result;

        int activeModCount = INI.Parse<int>(modsDb["Main"]["ActiveModCount"], 0);

        foreach (var entry in modsDb["Mods"].Keys)
        {
            for (int i = 0; i < activeModCount; i++)
            {
                if (modsDb["Main"][$"ActiveMod{i}"].Contains(entry))
                {
                    result.Add(new Mod(modsDb["Mods"][entry]));
                }
            }
        }

        return result;
    }

    public Mod GetModByID(string in_id)
    {
        foreach (var mod in GetMods())
        {
            if (mod.ID == in_id)
                return mod;
        }

        return null;
    }

    public List<Mod> FindModsByName(string name)
    {
        List<Mod> result = new();

        foreach (var mod in GetMods())
        {
            if (mod.Name.Contains(name))
            {
                result.Add(mod);
            }
        }

        return result;
    }

    public List<string> GetCodes()
    {
        List<string> result = new();

        var modsDb = GetModsDatabase();

        if (modsDb == null)
            return result;

        foreach (var value in modsDb["Codes"].Values)
            result.Add(value);

        return result;
    }

    public class Mod
    {
        public string Name { get; set; } = string.Empty;

        public string Version { get; set; } = string.Empty;

        public string Author { get; set; } = string.Empty;

        public string Description { get; set; } = string.Empty;

        public string Date { get; set; } = string.Empty;

        public string AuthorURL { get; set; } = string.Empty;

        public string UpdateServer { get; set; } = string.Empty;

        public string SaveFile { get; set; } = string.Empty;

        public string ID { get; set; } = string.Empty;

        public List<string> IncludeDirs { get; set; } = new();

        public List<ModDependency> Dependencies { get; set; } = new();

        public string DLLFile { get; set; } = string.Empty;

        public string CodeFile { get; set; } = string.Empty;

        public string ConfigSchemaFile { get; set; } = string.Empty;

        public string Path { get; set; } = string.Empty;

        public Dictionary<string, Dictionary<string, string>> Ini { get; set; } = new();

        public Mod(string modIniPath)
        {
            var ini = INI.Read(modIniPath);

            if (ini == null)
                return;

            Name             = INI.GetField<string>(ini, "Desc", "Title", Name);
            Version          = INI.GetField<string>(ini, "Desc", "Version", Version);
            Author           = INI.GetField<string>(ini, "Desc", "Author", Author);
            Description      = INI.GetField<string>(ini, "Desc", "Description", Description);
            Date             = INI.GetField<string>(ini, "Desc", "Date", Date);
            AuthorURL        = INI.GetField<string>(ini, "Desc", "AuthorURL", AuthorURL);
            UpdateServer     = INI.GetField<string>(ini, "Main", "UpdateServer", UpdateServer);
            SaveFile         = INI.GetField<string>(ini, "Main", "SaveFile", SaveFile);
            ID               = INI.GetField<string>(ini, "Main", "ID", ID);
            DLLFile          = INI.GetField<string>(ini, "Main", "DLLFile", DLLFile);
            CodeFile         = INI.GetField<string>(ini, "Main", "CodeFile", CodeFile);
            ConfigSchemaFile = INI.GetField<string>(ini, "Main", "ConfigSchemaFile", ConfigSchemaFile);

            Path             = System.IO.Path.GetDirectoryName(modIniPath);
            Ini              = ini;

            int includeDirCount = INI.GetField<int>(ini, "Main", "IncludeDirCount", 1);

            for (int i = 0; i < includeDirCount; i++)
                IncludeDirs.Add(INI.GetField<string>(ini, "Main", $"IncludeDir{i}", "."));

            int dependencyCount = INI.GetField<int>(ini, "Main", "DependsCount", 0);

            for (int i = 0; i < dependencyCount; i++)
                Dependencies.Add(new ModDependency(INI.GetField<string>(ini, "Main", $"Depends{i}", "")));
        }
    }

    public class ModDependency
    {
        public string ID { get; set; }

        public string Name { get; set; }
        
        public string Link { get; set; }

        public string Version { get; set; }

        public ModDependency(string in_id, string in_name, string in_link, string in_version)
        {
            ID = in_id;
            Name = in_name;
            Link = in_link;
            Version = in_version;
        }

        public ModDependency(string in_csv)
        {
            var fields = in_csv.Split('|');

            for (int i = 0; i < fields.Length; i++)
            {
                switch (i)
                {
                    case 0:
                        ID = fields[i];
                        break;

                    case 1:
                        Name = fields[i];
                        break;

                    case 2:
                    {
                        if (fields.Length > 2)
                        {
                            Link = fields[i];
                        }
                        else
                        {
                            Version = fields[i];
                        }

                        break;
                    }

                    case 3:
                        Version = fields[i];
                        break;
                }
            }
        }
    }
}
Library "INI" by "Hyper"
{
    using System.Collections.Generic;
    using System.IO;
    
    public Dictionary<string, Dictionary<string, string>> Read(string path)
    {
        Dictionary<string, Dictionary<string, string>> result = new();

        if (!File.Exists(path))
            return result;

        using (StreamReader reader = new StreamReader(path))
        {
            string section = string.Empty;
            string line = string.Empty;

            // Add root section.
            result.Add(section, new Dictionary<string, string>());

            while ((line = reader.ReadLine()) != null)
            {
                if (line.StartsWith("[") && line.EndsWith("]"))
                {
                    section = line.Substring(1, line.Length - 2);
                    result.Add(section, new Dictionary<string, string>());
                    continue;
                }

                if (line.StartsWith(";") || line.StartsWith("#"))
                    continue;

                int delimiterIndex = line.IndexOf('=');

                if (delimiterIndex == -1)
                    continue;

                string key = line.Substring(0, delimiterIndex);
                string value = line.Substring(delimiterIndex + 1);

                if (value.StartsWith("\"") && value.EndsWith("\"") && value.Length > 1)
                    value = value.Substring(1, value.Length - 2);
                
                result[section].Add(key, value);
            }
        }

        return result;
    }

    public T Parse<T>(string in_value, T in_defaultValue)
    {
        T result = in_defaultValue;

        if (typeof(T) == typeof(string))
        {
            result = (T)(object)in_value;
        }
        else if (typeof(T) == typeof(int))
        {
            if (int.TryParse(in_value, out int intValue))
            {
                result = (T)(object)intValue;
            }
        }
        else if (typeof(T) == typeof(double))
        {
            if (double.TryParse(in_value, out double doubleValue))
            {
                result = (T)(object)doubleValue;
            }
        }
        else if (typeof(T) == typeof(float))
        {
            if (float.TryParse(in_value, out float floatValue))
            {
                result = (T)(object)floatValue;
            }
        }

        return result;
    }

    public T GetField<T>(Dictionary<string, Dictionary<string, string>> in_ini, string in_section, string in_key, T in_defaultValue)
    {
        if (!in_ini.ContainsKey(in_section))
            return in_defaultValue;

        if (!in_ini[in_section].ContainsKey(in_key))
            return in_defaultValue;

        return Parse<T>(in_ini[in_section][in_key], in_defaultValue);
    }
}
Library "Logger" by "Hyper"
{
    #define PRINT_OBJECT(obj, format, caller) Logger.Utility(#obj + " = " + obj.ToString(format), caller);
    #define PRINT_OBJECT(obj, format) Logger.Utility(#obj + " = " + obj.ToString(format));

    public enum LogLevel
    {
        None,
        Utility,
        Warning,
        Error
    }

    public void Log(object message, LogLevel level = LogLevel.None, string caller = "")
    {
        var oldColour = Console.ForegroundColor;

        switch (level)
        {
            case LogLevel.Warning:
                Console.ForegroundColor = ConsoleColor.Yellow;
                break;

            case LogLevel.Error:
                Console.ForegroundColor = ConsoleColor.Red;
                break;

            case LogLevel.Utility:
                Console.ForegroundColor = ConsoleColor.Green;
                break;
        }

        Console.WriteLine(string.IsNullOrEmpty(caller) ? message.ToString() : $"[{caller}] {message}");

        Console.ForegroundColor = oldColour;
    }

    public void Utility(object message, string caller = "")
    {
        Log(message, LogLevel.Utility, caller);
    }

    public void Warning(object message, string caller = "")
    {
        Log(message, LogLevel.Warning, caller);
    }

    public void Error(object message, string caller = "")
    {
        Log(message, LogLevel.Error, caller);
    }
}
Library "MathHelpers" by "Hyper" 
{
    using System.Collections.Generic;

    public T Clamp<T>(T in_value, T in_minValue, T in_maxValue) where T : IComparable<T>
    {
        if (in_value.CompareTo(in_minValue) < 0)
        {
            return in_minValue;
        }
        else if (in_value.CompareTo(in_maxValue) > 0)
        {
            return in_maxValue;
        }
        else
        {
            return in_value;
        }
    }

    public T Clamp01<T>(T value) where T : IComparable<T>
    {
        if (value.CompareTo(default(T)) < 0)
        {
            return default(T);
        }
        else if (value.CompareTo((T)Convert.ChangeType(1, typeof(T))) > 0)
        {
            return (T)Convert.ChangeType(1, typeof(T));
        }
        else
        {
            return value;
        }
    }

    public T FloatPercentToRange<T>(float in_value)
    {
        if (typeof(T) == typeof(sbyte))
        {
            return (T)(object)(byte)(in_value * (sbyte.MaxValue * 1.0f));
        }
        else if (typeof(T) == typeof(byte))
        {
            return (T)(object)(byte)(in_value * (byte.MaxValue * 1.0f));
        }
        else if (typeof(T) == typeof(short))
        {
            return (T)(object)(short)(in_value * (short.MaxValue * 1.0f));
        }
        else if (typeof(T) == typeof(ushort))
        {
            return (T)(object)(ushort)(in_value * (ushort.MaxValue * 1.0f));
        }
        else if (typeof(T) == typeof(int))
        {
            return (T)(object)(int)(in_value * (int.MaxValue * 1.0f));
        }
        else if (typeof(T) == typeof(uint))
        {
            return (T)(object)(uint)(in_value * (uint.MaxValue * 1.0f));
        }
        else if (typeof(T) == typeof(long))
        {
            return (T)(object)(long)(in_value * (long.MaxValue * 1.0f));
        }
        else if (typeof(T) == typeof(ulong))
        {
            return (T)(object)(ulong)(in_value * (ulong.MaxValue * 1.0f));
        }
        
        return default;
    }
    
    public float Lerp(float in_start, float in_end, float in_time)
    {
        return in_start + (in_end - in_start) * in_time;
    }

    public static float InverseLerp(float a, float b, float value)
    {
        if (a == b)
            return 0.0f;

        return Clamp01<float>((value - a) / (b - a));
    }

    public static float ToDegrees(float in_radians)
    {
        return in_radians * (180.0f / (float)Math.PI);
    }

    public static float ToRadians(float in_degrees)
    {
        return in_degrees * ((float)Math.PI / 180.0f);
    }

    public static float WrapToRadians(float in_value)
    {
        float sign = in_value > 0.0f ? 1.0f : -1.0f;
        float mod = (float)Math.Abs(in_value) % 6.28319f;

        return mod * sign;
    }
}
Library "Memory" by "Hyper & Sajid" 
{
    using System.Collections.Generic;
    using System.Runtime.InteropServices;
    using System.Runtime.CompilerServices;
    using System.Text;

    private static Dictionary<nint, List<byte>> _preservedMemory = new();

    public void Preserve(nint in_location, nint in_length, bool in_isPreservedOnce = true)
    {
        if (in_location == 0)
            return;

        if (in_isPreservedOnce)
        {
            if (_preservedMemory.ContainsKey(in_location))
                return;
        }
        else
        {
            if (_preservedMemory.ContainsKey(in_location))
                _preservedMemory.Remove(in_location);
        }
        
        List<byte> buffer = new();
        for (nint i = 0; i < in_length; i++)
            buffer.Add(Read<byte>(in_location + i));

        _preservedMemory.Add(in_location, buffer);
    }

    public void Preserve(long in_location, long in_length, bool in_isPreservedOnce = true)
    {
        Preserve((nint)in_location, (nint)in_length, in_isPreservedOnce);
    }

    public void Restore(nint in_location)
    {
        if (in_location == 0)
            return;

        if (!_preservedMemory.ContainsKey(in_location))
            return;

        nint i = 0;
        foreach (byte b in _preservedMemory[in_location])
        {
            WriteProtected<byte>(in_location + i, b);
            i++;
        }
    }

    public void Restore(long in_location)
    {
        Restore((nint)in_location);
    }

    public nint ReadCall(nint in_location)
    {
        if (in_location == 0)
            return 0;

        return in_location + Read<int>(in_location + 0x01) + 0x05;
    }

    public long ReadCall(long in_location)
    {
        return (long)ReadCall((nint)in_location);
    }

    public nint ReadEffectiveAddress(nint in_location)
    {
        if (in_location == 0)
            return 0;

        return in_location + Read<int>(in_location + 0x03) + 0x07;
    }

    public long ReadEffectiveAddress(long in_location)
    {
        return (long)ReadEffectiveAddress((nint)in_location);
    }

    public enum JumpType : sbyte
    {
        Unknown = -1,
        ShortCond,
        NearJmp,
        NearCond,
        LongJmp
    }

    public JumpType ReadJumpOpcode(nint in_location)
    {
        JumpType result = JumpType.Unknown;

        if (in_location == 0)
            return result;

        byte opcode = Read<byte>(in_location);

        if ((opcode & 0xF0) == 0x70)
        {
            result = JumpType.ShortCond;
        }
        else
        {
            switch (opcode)
            {
                case 0xE3:
                case 0xEB:
                    result = JumpType.ShortCond;
                    break;

                case 0xE9:
                    result = JumpType.NearJmp;
                    break;

                case 0x0F:
                    result = JumpType.NearCond;
                    break;

                case 0xFF:
                    result = JumpType.LongJmp;
                    break;
            }
        }

        return result;
    }

    public JumpType ReadJumpOpcode(long in_location)
    {
        return ReadJumpOpcode((nint)in_location);
    }

    public nint ReadJump(nint in_location)
    {
        if (in_location == 0)
            return 0;

        switch (ReadJumpOpcode(in_location))
        {
            case JumpType.ShortCond:
                return in_location + Read<byte>(in_location + 0x01) + 0x02;

            case JumpType.NearJmp:
                return in_location + Read<int>(in_location + 0x01) + 0x05;

            case JumpType.NearCond:
                return in_location + Read<int>(in_location + 0x02) + 0x06;

            case JumpType.LongJmp:
                return (nint)Read<long>(in_location + 0x06);
        }

        return 0;
    }

    public long ReadJump(long in_location)
    {
        return (long)ReadJump((nint)in_location);
    }

    public void WriteForceJump(nint in_location)
    {
        if (in_location == 0)
            return;
        
        switch (ReadJumpOpcode(in_location))
        {
            case JumpType.ShortCond:
                WriteProtected<byte>(in_location, 0xEB);
                break;

            case JumpType.NearCond:
                WriteProtected<byte>(in_location, 0xE9);
                WriteProtected<int>(in_location + 0x01, Read<int>(in_location + 0x02) + 0x01);
                break;
        }
    }

    public void WriteForceJump(long in_location)
    {
        WriteForceJump((nint)in_location);
    }

    public nint ReadThunk(nint in_location, nint in_offset = 0)
    {
        return ReadJump(ReadCall(in_location) + in_offset);
    }

    public long ReadThunk(long in_location, long in_offset = 0)
    {
        return (long)ReadThunk((nint)in_location, (nint)in_offset);
    }

    public void WriteString(long in_location, string in_str, Encoding in_encoding)
    {
        WriteProtected<byte>(in_location, in_encoding.GetBytes(in_str));
    }

    public void WriteString(long in_location, string in_str)
    {
        WriteString(in_location, in_str, Encoding.ASCII);
    }

    public void PrintMemory<T>(IntPtr in_address, int in_rowCount) where T : unmanaged
    {
        for (int i = 0; i < in_rowCount * 16; i += 16)
        {
            Console.Write($"{(in_address + i).ToInt64():X16}: ");

            if (typeof(T) == typeof(byte) || typeof(T) == typeof(sbyte))
            {
                for (int j = 0; j < 16; j++)
                    Console.Write($"{Read<T>(in_address + i + j):X2} ");
            }
            else if (typeof(T) == typeof(short) || typeof(T) == typeof(ushort))
            {
                for (int j = 0; j < 16; j += 2)
                    Console.Write($"{Read<T>(in_address + i + j):X4} ");
            }
            else if (typeof(T) == typeof(int) || typeof(T) == typeof(uint))
            {
                for (int j = 0; j < 16; j += 4)
                    Console.Write($"{Read<T>(in_address + i + j):X8} ");
            }
            else if (typeof(T) == typeof(long) || typeof(T) == typeof(ulong))
            {
                for (int j = 0; j < 16; j += 8)
                    Console.Write($"{Read<T>(in_address + i + j):X16} ");
            }
            else if (typeof(T) == typeof(float))
            {
                for (int j = 0; j < 16; j += 4)
                    Console.Write($"{Read<float>(in_address + i + j)} ");
            }
            else if (typeof(T) == typeof(double))
            {
                for (int j = 0; j < 16; j += 8)
                    Console.Write($"{Read<double>(in_address + i + j)} ");
            }

            Console.WriteLine();
        }
    }

    public void PrintMemory(IntPtr in_address, int in_rowCount)
    {
        PrintMemory<byte>(in_address, in_rowCount);
    }
    
    public struct Pointer<T> where T : unmanaged
    {
        public T* pData;

        public Pointer(ref T data)
        {
            fixed(T* dataPtr = &data)
            {
                pData = dataPtr;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Pointer(T* in_pData)
        {
            pData = in_pData;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsValid()
        {
            return pData != null;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T Ref()
        {
            return ref *pData;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T* Get()
        {
            return pData;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator bool(Pointer<T> self) => self.IsValid();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator Pointer<T>(T* data) => new(data);

        public override string ToString() => $"0x{((long)pData):X}";
    }
}
Library "VectorHelpers" by "Hyper" 
{
    #load "System.Numerics.dll"

    using System.Numerics;

    public static Vector3 ClampMagnitude(Vector3 in_vector, float in_maxMagnitude)
    {
        if (in_vector.Length() > in_maxMagnitude * in_maxMagnitude)
            return Vector3.Normalize(in_vector) * in_maxMagnitude;

        return in_vector;
    }

    public static Vector3 GetForward(Quaternion in_rotation)
    {
        return Vector3.Transform(Vector3.UnitZ, Quaternion.Normalize(in_rotation));
    }

    public static float GetMagnitude(Vector3 in_velocity)
    {
        return in_velocity.Length();
    }

    public static float GetHorizontalMagnitude(Vector3 in_velocity)
    {
        return (float)Math.Sqrt(in_velocity.X * in_velocity.X + in_velocity.Z * in_velocity.Z);
    }

    public static float GetVerticalMagnitude(Vector3 in_velocity)
    {
        return in_velocity.Y;
    }

    public static Quaternion LookRotation(Vector3 in_forward, Vector3 in_upward)
    {
        in_forward = Vector3.Normalize(in_forward);
        in_upward = Vector3.Normalize(in_upward);

        var right = Vector3.Cross(in_upward, in_forward);
        in_upward = Vector3.Cross(in_forward, right);

        var m = new Matrix4x4
        (
            right.X,      right.Y,      right.Z,      0.0f,
            in_upward.X,  in_upward.Y,  in_upward.Z,  0.0f,
            in_forward.X, in_forward.Y, in_forward.Z, 0.0f,
            0.0f,         0.0f,         0.0f,         1.0f
        );

        return Quaternion.CreateFromRotationMatrix(m);
    }

    public static Quaternion LookRotation(Vector3 in_forward)
    {
        return LookRotation(in_forward, Vector3.UnitY);
    }
}
Library "XInput" by "Hyper" 
{
    #lib "MathHelpers"

    #load "System.Numerics.dll"

    using System.Numerics;
    using System.Runtime.InteropServices;

    [DllImport("xinput1_4.dll", EntryPoint = "XInputGetState")]
    public extern int XInputGetState(int in_dwUserIndex, ref State in_pState);
    
    [DllImport("xinput1_4.dll", EntryPoint = "XInputSetState")]
    public extern int XInputSetState(int in_dwUserIndex, ref Vibration in_pVibration);

    public const short XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE = 7849;
    public const short XINPUT_GAMEPAD_RIGHT_THUMB_DEADZONE = 8689;

    private static float _leftMotorSpeed = 0.0f;
    private static float _rightMotorSpeed = 0.0f;

    [Flags]
    public enum Buttons : ushort
    {
        DPAD_UP        = 0x0001,
        DPAD_DOWN      = 0x0002,
        DPAD_LEFT      = 0x0004,
        DPAD_RIGHT     = 0x0008,
        START          = 0x0010,
        BACK           = 0x0020,
        LEFT_THUMB     = 0x0040,
        RIGHT_THUMB    = 0x0080,
        LEFT_SHOULDER  = 0x0100,
        RIGHT_SHOULDER = 0x0200,
        A              = 0x1000,
        B              = 0x2000,
        X              = 0x4000,
        Y              = 0x8000
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct State
    {
        public int dwPacketNumber;
        public Gamepad Gamepad;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct Gamepad
    {
        public Buttons wButtons;
        public byte bLeftTrigger;
        public byte bRightTrigger;
        public short sThumbLX;
        public short sThumbLY;
        public short sThumbRX;
        public short sThumbRY;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct Vibration
    {
        public ushort wLeftMotorSpeed;
        public ushort wRightMotorSpeed;

        public Vibration(ushort in_leftMotorSpeed, ushort in_rightMotorSpeed)
        {
            wLeftMotorSpeed = in_leftMotorSpeed;
            wRightMotorSpeed = in_rightMotorSpeed;

            _leftMotorSpeed = in_leftMotorSpeed / 65535.0f;
            _rightMotorSpeed = in_rightMotorSpeed / 65535.0f;
        }

        public Vibration(float in_leftMotorSpeed, float in_rightMotorSpeed)
        {
            wLeftMotorSpeed = MathHelpers.FloatPercentToRange<ushort>(in_leftMotorSpeed);
            wRightMotorSpeed = MathHelpers.FloatPercentToRange<ushort>(in_rightMotorSpeed);

            _leftMotorSpeed = in_leftMotorSpeed;
            _rightMotorSpeed = in_rightMotorSpeed;
        }

        public Vibration(ushort in_motorSpeed)
        {
            wLeftMotorSpeed = wRightMotorSpeed = in_motorSpeed;
            _leftMotorSpeed = _rightMotorSpeed = in_motorSpeed / 65535.0f;
        }

        public Vibration(float in_motorSpeed)
        {
            wLeftMotorSpeed = wRightMotorSpeed = MathHelpers.FloatPercentToRange<ushort>(in_motorSpeed);
            _leftMotorSpeed = _rightMotorSpeed = in_motorSpeed;
        }
    }

    public State? GetState()
    {
        var pState = new State();

        if (XInputGetState(0, ref pState) != 0)
            return null;

        return pState;
    }

    public void SetState(Vibration in_vibration)
    {
        XInputSetState(0, ref in_vibration);
    }

    public Vector2 GetAnalog(int in_analogIndex, bool in_isTestDeadzone = true)
    {
        var pState = GetState();

        if (pState == null)
            return Vector2.Zero;

        Vector2 v = Vector2.Zero;

        switch (in_analogIndex)
        {
            case 0:
                v = new Vector2(pState.Value.Gamepad.sThumbLX / 32767.0f, pState.Value.Gamepad.sThumbLY / 32767.0f);
                break;

            case 1:
                v = new Vector2(pState.Value.Gamepad.sThumbRX / 32767.0f, pState.Value.Gamepad.sThumbRY / 32767.0f);
                break;
        }

        if (in_isTestDeadzone)
        {
            v = IsAnalogNeutral(in_analogIndex)
                ? Vector2.Zero
                : v;
        }

        return v;
    }

    // Use Player.Input for keyboard parity!
    public bool IsButtonDown(Buttons in_buttons)
    {
        var pState = GetState();

        if (pState == null)
            return false;

        return (pState.Value.Gamepad.wButtons & in_buttons) != 0;
    }

    public float GetTrigger(int in_triggerIndex)
    {
        var pState = GetState();

        if (pState == null)
            return 0;

        switch (in_triggerIndex)
        {
            case 0:
                return pState.Value.Gamepad.bLeftTrigger / 255.0f;

            case 1:
                return pState.Value.Gamepad.bRightTrigger / 255.0f;
        }

        return 0;
    }

    public bool IsAnalogNeutral(int in_analogIndex)
    {
        var pState = GetState();

        if (pState == null)
            return true;

        switch (in_analogIndex)
        {
            case 0:
            {
                short x = pState.Value.Gamepad.sThumbLX;
                short y = pState.Value.Gamepad.sThumbLY;

                return x < XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE &&
                    x > -XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE &&
                    y < XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE &&
                    y > -XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE;
            }

            case 1:
            {
                short x = pState.Value.Gamepad.sThumbRX;
                short y = pState.Value.Gamepad.sThumbRY;

                return x < XINPUT_GAMEPAD_RIGHT_THUMB_DEADZONE &&
                    x > -XINPUT_GAMEPAD_RIGHT_THUMB_DEADZONE &&
                    y < XINPUT_GAMEPAD_RIGHT_THUMB_DEADZONE &&
                    y > -XINPUT_GAMEPAD_RIGHT_THUMB_DEADZONE;
            }
        }

        return true;
    }

    public Vibration GetVibration()
    {
        return new Vibration(_leftMotorSpeed, _rightMotorSpeed);
    }

    public void SetVibration(float in_value)
    {
        SetState(new Vibration(in_value));
    }

    public void SetVibration(int in_motorIndex, float in_value)
    {
        switch (in_motorIndex)
        {
            case 0:
            {
                SetState(new Vibration(in_value, _rightMotorSpeed));
                break;
            }

            case 1:
            {
                SetState(new Vibration(_leftMotorSpeed, in_value));
                break;
            }
        }
    }
}



Code "Enable Lives in Anniversary Mode" in "Gameplay" by "ĐeäTh" does "Enabling this code will cause Anniversary Mode to use a different set of saves from normal, and your regular Anniversary Mode saves will be inaccessible." 
//
    #lib "RSDK"
//
{
    // Check if Sonic 1 game.playMode is set to BOOT_PLAYMODE_ANNIVERSARY
    // Version 1.0.0 and 1.0.4: RSDKv4DataPtr + 0x1A4
    if (*(byte*)(RSDK.GetRSDKv4DataPtr() + 0x1FC) == 1)
    {
        // Sonic 1 Coin Mode
        WriteProtected<byte>(RSDK.GetRSDKv4DataPtr() + 0x1FC, 0x00);
    }

    // Check if Sonic 2 game.playMode is set to BOOT_PLAYMODE_ANNIVERSARY
    if (*(byte*)(RSDK.GetRSDKv4DataPtr() + 0x23C) == 1)
    {
        // Sonic 2 Coin Mode
        WriteProtected<byte>(RSDK.GetRSDKv4DataPtr() + 0x288, 0x00);
    }

    // Check if RSDKv3 game.playMode is set to BOOT_PLAYMODE_ANNIVERSARY
    if (*(byte*)(RSDK.GetRSDKv3DataPtr() + 0x1DC) == 1)
    {
        // Sonic CD Coin Mode
        WriteProtected<byte>(RSDK.GetRSDKv3DataPtr() + 0x220, 0x00);
    }

    // Sonic 3&K Coin Mode and HUD Update
    if (RSDK.GetRSDKGlobalsAbsPtr() != 0)
    {
        // Check if game.playMode is set to BOOT_PLAYMODE_ANNIVERSARY
        // Version 1.0.0: RSDKGlobalsPtr + 0x447D08
        // Version 1.0.4: RSDKGlobalsPtr + 0x4C3508 (Thanks to RDC)
        // Version 2.0.0: RSDKGlobalsPtr + RSDKGlobalsOffset + 0x104
        if (*(byte*)(RSDK.GetRSDKGlobalsAbsPtr() + 0x10C) == 1)
        {
            // HUD Update
            // Version 1.0.0: RSDKGlobalsPtr + 0x447D20
            // Version 1.0.4: RSDKGlobalsPtr + 0x4C34D4 (Thanks to RDC)
            WriteProtected<byte>(RSDK.GetRSDKGlobalsAbsPtr() + 0xD0, 0x00);

            // Coin Mode
            // Version 1.0.0: RSDKGlobalsPtr + 0x447CD4
            // Version 1.0.4: RSDKGlobalsPtr + 0x4C3520 (Thanks to RDC)
            // Version 2.0.0: RSDKGlobalsPtr + RSDKGlobalsOffset + 0x124
            WriteProtected<byte>(RSDK.GetRSDKGlobalsAbsPtr() + 0x124, 0x00);
        }
    }
}



Code "Enable Lives in Mirror Mode" in "Gameplay" by "ĐeäTh" does "Enabling this code will cause Mirror Mode to use a different set of saves from normal, and your regular Mirror Mode saves will be inaccessible." 
//
    #lib "RSDK"
//
{
    // Check if Sonic 1 game.playMode is set to BOOT_PLAYMODE_MIRRORING
    // Version 1.0.0 and 1.0.4: RSDKv4DataPtr + 0x1A4
    if (*(byte*)(RSDK.GetRSDKv4DataPtr() + 0x1FC) == 3)
    {
        // Sonic 1 Coin Mode
        WriteProtected<byte>(RSDK.GetRSDKv4DataPtr() + 0x1FC, 0x00);
    }

    // Check if Sonic 2 game.playMode is set to BOOT_PLAYMODE_MIRRORING
    if (*(byte*)(RSDK.GetRSDKv4DataPtr() + 0x23C) == 3)
    {
        // Sonic 2 Coin Mode
        WriteProtected<byte>(RSDK.GetRSDKv4DataPtr() + 0x288, 0x00);
    }

    // Check if RSDKv3 game.playMode is set to BOOT_PLAYMODE_MIRRORING
    if (*(byte*)(RSDK.GetRSDKv3DataPtr() + 0x1DC) == 3)
    {
        // Sonic CD Coin Mode
        WriteProtected<byte>(RSDK.GetRSDKv3DataPtr() + 0x220, 0x00);
    }

    // Sonic 3&K Coin Mode and HUD Update
    if (RSDK.GetRSDKGlobalsAbsPtr() != 0)
    {
        // Check if game.playMode is set to BOOT_PLAYMODE_ANNIVERSARY
        // Version 1.0.0: RSDKGlobalsPtr + 0x447D08
        // Version 1.0.4: RSDKGlobalsPtr + 0x4C3508 (Thanks to RDC)
        // Version 2.0.0: RSDKGlobalsPtr + RSDKGlobalsOffset + 0x104
        if (*(byte*)(RSDK.GetRSDKGlobalsAbsPtr() + 0x10C) == 3)
        {
            // HUD Update
            // Version 1.0.0: RSDKGlobalsPtr + 0x447D20
            // Version 1.0.4: RSDKGlobalsPtr + 0x4C34D4 (Thanks to RDC)
            WriteProtected<byte>(RSDK.GetRSDKGlobalsAbsPtr() + 0xD0, 0x00);

            // Coin Mode
            // Version 1.0.0: RSDKGlobalsPtr + 0x447CD4
            // Version 1.0.4: RSDKGlobalsPtr + 0x4C3520 (Thanks to RDC)
            // Version 2.0.0: RSDKGlobalsPtr + RSDKGlobalsOffset + 0x124
            WriteProtected<byte>(RSDK.GetRSDKGlobalsPtr() + 0x124, 0x00);
        }
    }
}



Library "Helpers" by "Hyper" 
{
    #define UNMANAGED_FUNCTION(returnType, functionName, ...) \
        [System.Runtime.InteropServices.UnmanagedFunctionPointer(System.Runtime.InteropServices.CallingConvention.StdCall)] \
        public delegate returnType T##functionName(__VA_ARGS__); \
        public static T##functionName _del##functionName = new T##functionName(functionName); \
        public static long _fp##functionName = (long)System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate(_del##functionName); \
        public static returnType functionName(__VA_ARGS__)

    #define GET_UNMANAGED_FUNCTION_PTR(functionName) _fp##functionName

    #define CREATE_FUNCTION_PTR(returnType, functionName, location, ...) \
        [System.Runtime.InteropServices.UnmanagedFunctionPointer(System.Runtime.InteropServices.CallingConvention.StdCall)] \
        public delegate returnType T##functionName(__VA_ARGS__); \
        public static long _addr##functionName = location;

    #define GET_FUNCTION_PTR(functionName) System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer<T##functionName>((IntPtr)_addr##functionName)

    #define TO_STRING_PTR(str) (long)System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(str)

    #define FROM_STRING_PTR(ptr) System.Runtime.InteropServices.Marshal.PtrToStringAnsi((IntPtr)ptr)
}



Library "Reflection" by "Hyper" 
{
    #lib "Resources"

    using System.Collections.Generic;

    private static bool _isInitialised = false;
    private static List<string> _rflPointersQueue = new();
    private static Dictionary<string, object> _rflBackups = new();
    private static Dictionary<string, long> _rflPointers = new();

    public class ReflectionInfo<T> where T : unmanaged
    {
        public string Name;
        public Type Type;
        public T* pData;

        public ReflectionInfo(string name, T* pData)
        {
            this.Name = name;
            this.Type = typeof(T);
            this.pData = pData;
        }

        public override string ToString()
        {
            return $"{Name} : 0x{((IntPtr)pData).ToString("X16")}";
        }
    }

    private void Init()
    {
    	if (_isInitialised)
    		return;
    	
    	long GetReflectionPtr(string resourceName, string resourceType, long pResourceData)
    	{
    		if (resourceType != "ResReflection")
    			return pResourceData;

    		if (_rflPointersQueue.Contains(resourceName))
    		{
    			long ptr = *(long*)(pResourceData + 0x60);

    			if (_rflPointers.ContainsKey(resourceName))
    			{
    				_rflPointers[resourceName] = ptr;
    			}
    			else
    			{
    				_rflPointers.Add(resourceName, ptr);
    			}
    		}

    		return pResourceData;
    	}

    	Resources.AddResourceDataAction(GetReflectionPtr);

    	_isInitialised = true;
    }

    public T* GetDataPtr<T>(string rflName) where T : unmanaged
    {
    	Init();

    	if (!_rflPointersQueue.Contains(rflName))
    		_rflPointersQueue.Add(rflName);

    	if (!_rflPointers.ContainsKey(rflName))
    		return null;

        long ptr = _rflPointers[rflName];

        if (ptr == 0)
            return null;

        // Check for BINA signature.
        if (*(int*)(ptr - 0x40) != 0x414E4942)
            return null;

        var result = (T*)ptr;

    	if (result != null && !_rflBackups.ContainsKey(rflName))
            _rflBackups.Add(rflName, *result);

    	return result;
    }

    public ReflectionInfo<T> GetDataInfo<T>(string rflName) where T : unmanaged
    {
        return new ReflectionInfo<T>(rflName, GetDataPtr<T>(rflName));
    }

    public object GetOriginalData(string rflName)
    {
        if (!_rflBackups.ContainsKey(rflName))
            return null;

        return _rflBackups[rflName];
    }

    public T GetOriginalData<T>(string rflName) where T : unmanaged
    {
        return (T)GetOriginalData(rflName);
    }
}



Library "ReflectionHelpers" by "Hyper" 
{
    #lib "Bitwise"
    #lib "Reflection"
    
    #define RFL_GET_PARAM(info, hierarchy) info.pData->hierarchy

    #define RFL_SET_PARAM(info, hierarchy, value) info.pData->hierarchy = value

    #define RFL_RESET_PARAM(info, type, hierarchy) info.pData->hierarchy = Reflection.GetOriginalData<type>(info.Name).hierarchy
}



Library "Resources" by "Hyper" 
{
    #include "Helpers" noemit
    
    #lib "Memory"
    
    using System.Collections.Generic;
    using System.Runtime.InteropServices;
    
    private static bool _isInitialised = false;
    
    private static string _currentResourceName = string.Empty;
    private static string _currentResourceType = string.Empty;
    
    public delegate string TResourceNotifyAction(string resourceName, string resourceType);
    private static List<TResourceNotifyAction> _resourceNotifyActions = new();
    
    public delegate long TResourceDataAction(string resourceName, string resourceType, long pResourceData);
    private static List<TResourceDataAction> _resourceDataActions = new();
    
    UNMANAGED_FUNCTION(long, GetResourceInfo, long pResourceName, long pResourceTypeName)
    {
        _currentResourceName = Marshal.PtrToStringAnsi((IntPtr)pResourceName);
        _currentResourceType = Marshal.PtrToStringAnsi((IntPtr)pResourceTypeName);
    
    	foreach (TResourceNotifyAction action in _resourceNotifyActions)
    		pResourceName = (long)Marshal.StringToHGlobalAnsi(action.Invoke(_currentResourceName, _currentResourceType));
    	
        return pResourceName;
    }
    
    UNMANAGED_FUNCTION(long, GetResourceData, long pResourceData)
    {
    	foreach (TResourceDataAction action in _resourceDataActions)
    		pResourceData = action.Invoke(_currentResourceName, _currentResourceType, pResourceData);
    
        return pResourceData;
    }
    
    private void Init()
    {
    	if (_isInitialised)
    		return;
    
        /* 0x1405E8313 */
        long sigLoadResourceCaller = ScanSignature
        (
            "\xE8\xCC\xCC\xCC\xCC\x48\x85\xC0\x74\x22\x80\x78\x10\x00",
            "x????xxxxxxxxx"
        );
    
        if (sigLoadResourceCaller == 0)
            return;
    
        WriteAsmHook
        (
            $@"
                sub  rsp, 0xD0
                mov  rdi, r8
                mov  rbx, rdx
                mov  rsi, rcx
                mov  rcx, rdx
                mov  rdx, [rdi]
                mov  rax, {GET_UNMANAGED_FUNCTION_PTR(GetResourceInfo)}
                call rax
                mov  rdx, [rcx]
                mov  rbx, rdx
            ",
    
            /* 0x140790E9B */
            ScanSignature
            (
                "\x48\x81\xEC\xD0\x00\x00\x00\x49\x8B\xF8\x48\x8B\xDA",
                "xxxxxxxxxxxxx"
            ),
    
            HookBehavior.Replace
        );
    
        WriteAsmHook
        (
            $@"
                mov  rcx, rax
                mov  rax, {GET_UNMANAGED_FUNCTION_PTR(GetResourceData)}
                call rax
                lea  r11, qword ptr [rsp + 0xD8 + 0xFFFFFFFFFFFFFFF8]
                mov  rbx, qword ptr [r11 + 0x10]
                mov  rsi, qword ptr [r11 + 0x18]
    			mov  rsp, r11
            ",
            
            /* 0x140790F76 */
            Memory.ReadCall(sigLoadResourceCaller) + 0xE6,
    
            HookBehavior.Replace
        );
    
    	_isInitialised = true;
    }
    
    /*
    	Use notify actions for redirecting resources.
    	Redirected resources must already have their data present in memory loaded from their respective Packfiles.
        
    	Example;
    
    	string NotifyRedirectDashPanelResource(string resourceName, string resourceType)
    	{
    		if (resourceName == "cmn_obj_dashpanel")
    			return "cmnisl_obj_dashpanel";
    
    		return resourceName;
    	}
    
    	Resources.AddResourceNotifyAction(NotifyRedirectDashPanelResource);
    */
    public void AddResourceNotifyAction(TResourceNotifyAction action)
    {
    	Init();
    
    	if (_resourceNotifyActions.Contains(action))
    		return;
    
    	_resourceNotifyActions.Add(action);
    }
    
    public void RemoveResourceNotifyAction(TResourceNotifyAction action)
    {
    	Init();
    
    	if (!_resourceNotifyActions.Contains(action))
    		return;
    
    	_resourceNotifyActions.Remove(action);
    }
        
    /*
    	Use data actions for reading resource data.
        
    	Example;
    
    	SonicParameters.Root* pSonicParameters;
    
    	long GetSonicParametersPointer(string resourceName, string resourceType, long pResourceData)
    	{
    		if (resourceName == "player_common" && resourceType == "ResReflection")
    			pSonicParameters = (SonicParameters.Root*)(*(long*)(pResourceData + 0x60));
    
    		return pResourceData;
    	}
    
    	Resources.AddResourceDataAction(GetSonicParametersPointer);
    */
    public void AddResourceDataAction(TResourceDataAction action)
    {
    	Init();
    
    	if (_resourceDataActions.Contains(action))
    		return;
    
    	_resourceDataActions.Add(action);
    }
    
    public void RemoveResourceDataAction(TResourceDataAction action)
    {
    	Init();
    
    	if (!_resourceDataActions.Contains(action))
    		return;
    
    	_resourceDataActions.Remove(action);
    }
}



Library "RSDK" by "Hyper & ĐeäTh" 
{
    private static bool _isInitialised = false;

    private static long _pRSDKv3Data = 0;
    private static long _pRSDKv4Data = 0;
    private static long _pRSDKGlobals = 0;

    private static int _pRSDKGlobalsOffset = 0;

    private void Init()
    {
        if (_isInitialised)
            return;

        long sig = ScanSignature
        (
            "\x48\x63\xFB\x48\x8B\xCE\x48\x8B\xD7\x48\xC1\xE2\x05\x49\x03\xD6\xE8\x00\x00\x00\x00\x3C\x01\x74\x2D\x0F\xB6\x05\x00\x00\x00\x00\xFF\xC3\x3B\xD8\x7C\xDA\xB8\x00\x00\x00\x00\x48\x8B\x5C\x24\x00\x48\x8B\x6C\x24\x00\x48\x8B\x74\x24\x00\x48\x8B\x7C\x24\x00\x48\x83\xC4\x20\x41\x5E\xC3\x48\x8D\x05\x00\x00\x00\x00\x89\x2C\xB8\x8B\xC3\xEB\xD7",
            "xxxxxxxxxxxxxxxxx????xxxxxxx????xxxxxxx????xxxx?xxxx?xxxx?xxxx?xxxxxxxxxx????xxxxxxx"
        )
        + 0x46;

        _pRSDKv3Data = (long)sig + *((int*)IntPtr.Add(new IntPtr(sig), 3)) + 7;

        sig = ScanSignature
        (
            "\x4C\x8D\x35\x00\x00\x00\x00\x4C\x89\x7C\x24\x00\x4C\x8D\x3D\x00\x00\x00\x00\x66\x66\x0F\x1F\x84\x00\x00\x00\x00\x00\x48\x63\xD3\x48\x8B\xCD\x48\xC1\xE2\x05\x49\x03\xD7\xE8\x00\x00\x00\x00\x3C\x01\x75\x0B\xBB\x00\x00\x00\x00\x41\x89\x34\xBE\x8B\xFB\x0F\xB6\x05\x00\x00\x00\x00\xFF\xC3\x48\xFF\xC7\x3B\xD8\x7C\xCF\x4C\x8B\x7C\x24\x00\x4C\x8B\x74\x24\x00\x48\x8B\x7C\x24\x00\x48\x83\xC4\x20\x5E\x5D\x5B\xC3",
            "xxx????xxxx?xxx????xxxxxx????xxxxxxxxxxxxxx????xxxxx????xxxxxxxxx????xxxxxxxxxxxxx?xxxx?xxxx?xxxxxxxx"
        );

        _pRSDKv4Data = (long)sig + *((int*)IntPtr.Add(new IntPtr(sig), 3)) + 7;

        sig = ScanSignature
        (
            "\x48\x8B\x05\x00\x00\x00\x00\x8B\x80\x00\x00\x00\x00\x85\xC0\x78\x2D\x83\xF8\x01\x7E\x1F\x83\xF8\x02\x74\x11\x83\xC0\xFC\x83\xF8\x02\x77\x1B\x48\x8D\x0D\x00\x00\x00\x00\xEB\x19\x48\x8D\x0D\x00\x00\x00\x00\xEB\x10\x48\x8D\x0D\x00\x00\x00\x00\xEB\x07\x48\x8D\x0D\x00\x00\x00\x00\x48\x8B\x05\x00\x00\x00\x00\xB2\x02\x4C\x8B\x80\x00\x00\x00\x00\x41\xFF\xD0\x48\x8B\x0D\x00\x00\x00\x00\x66\x89\x41\x04",
            "xxx????xx????xxxxxxxxxxxxxxxxxxxxxxxxx????xxxxx????xxxxx????xxxxx????xxx????xxxxx????xxxxxx????xxxx"
        );

        _pRSDKGlobals = (long)sig + *((int*)IntPtr.Add(new IntPtr(sig), 3)) + 7;

        _pRSDKGlobalsOffset = *((int*)IntPtr.Add(new IntPtr(sig), 9));

        _isInitialised = true;
    }

    public long GetRSDKv3DataPtr()
    {
        Init();

        return _pRSDKv3Data;
    }

    public long GetRSDKv4DataPtr()
    {
        Init();

        return _pRSDKv4Data;
    }

    public long GetRSDKGlobalsPtr()
    {
        Init();

        return _pRSDKGlobals;
    }

    public long GetRSDKGlobalsOffset()
    {
        Init();

        return _pRSDKGlobalsOffset;
    }

    public long GetRSDKGlobalsAbsPtr()
    {
        Init();

        if (_pRSDKGlobals == 0)
            return 0;

        return *(long*)_pRSDKGlobals + _pRSDKGlobalsOffset;
    }
}



Library "UIRflParam"
{
    using System.Numerics;
    using System.Runtime.InteropServices;

    [StructLayout(LayoutKind.Explicit, Size = 4)]
    public struct InputHelpRflParam
    {
        [FieldOffset(0)] public float itemMargin;
    }

    public enum MainMenuMode : sbyte
    {
        MAINMENU_MODE_SONIC1 = 0,
        MAINMENU_MODE_SONICCD = 1,
        MAINMENU_MODE_SONIC2 = 2,
        MAINMENU_MODE_SONIC3K = 3,
        MAINMENU_MODE_MISSION = 4,
        MAINMENU_MODE_DATA = 5,
        MAINMENU_MODE_NUM = 6
    }

    [StructLayout(LayoutKind.Explicit, Size = 2)]
    public struct AllMapMenuItemParam
    {
        [FieldOffset(0)] public MainMenuMode menuMode;
        [FieldOffset(1)] public bool isRepeate;
    }

    [StructLayout(LayoutKind.Explicit, Size = 8)]
    public struct AllMapMenuRflParam
    {
        [FieldOffset(0)] public AllMapMenuItemParam itemUp;
        [FieldOffset(2)] public AllMapMenuItemParam itemDown;
        [FieldOffset(4)] public AllMapMenuItemParam itemLeft;
        [FieldOffset(6)] public AllMapMenuItemParam itemRight;
    }

    [StructLayout(LayoutKind.Explicit, Size = 60)]
    public struct MainMenuRflParam
    {
        [FieldOffset(0)]  public float textScrollSpeed;
        [FieldOffset(4)]  public bool textScrollLoop;
        [FieldOffset(5)]  public unsafe fixed byte /* AllMapMenuRflParam[6] */ _allMapMenu[48];

        public unsafe AllMapMenuRflParam* allMapMenu
        {
            get
            {
                fixed (byte* p_allMapMenu = _allMapMenu)
                    return (AllMapMenuRflParam*)p_allMapMenu;
            }
        }

        [FieldOffset(56)] public float backTitleInputTime;
    }

    [StructLayout(LayoutKind.Explicit, Size = 2)]
    public struct MenuFPSRflParam
    {
        [FieldOffset(0)] public bool fixedFrame;
        [FieldOffset(1)] public bool isFPS30;
    }

    [StructLayout(LayoutKind.Explicit, Size = 88)]
    public struct MenuRflParam
    {
        [FieldOffset(0)]  public InputHelpRflParam inputHelpParam;
        [FieldOffset(4)]  public MainMenuRflParam mainMenuParam;
        [FieldOffset(64)] public MenuFPSRflParam fpsParam;
        [FieldOffset(66)] public MenuFPSRflParam fpsParamNX;
        [FieldOffset(68)] public MenuFPSRflParam fpsParamORBIS;
        [FieldOffset(70)] public MenuFPSRflParam fpsParamDURANGO;
        [FieldOffset(72)] public float missionOutWaitTimer;
        [FieldOffset(76)] public float mydataOutWaitTimer;
        [FieldOffset(80)] public float museumOutWaitTimer;
        [FieldOffset(84)] public float optionOutWaitTimer;
    }

    [StructLayout(LayoutKind.Explicit, Size = 80)]
    public struct AdvertiseRflParam
    {
        [FieldOffset(0)]  public float CESA_autoTimer;
        [FieldOffset(4)]  public float CESA_skipTimer;
        [FieldOffset(8)]  public float CESA_startTimer;
        [FieldOffset(12)] public float CESA_endTimer;
        [FieldOffset(16)] public float CAUTION_LIGHT_autoTimer;
        [FieldOffset(20)] public float CAUTION_LIGHT_skipTimer;
        [FieldOffset(24)] public float CAUTION_LIGHT_startTimer;
        [FieldOffset(28)] public float CAUTION_LIGHT_endTimer;
        [FieldOffset(32)] public float SEGA_LOGO_autoTimer;
        [FieldOffset(36)] public float SEGA_LOGO_skipTimer;
        [FieldOffset(40)] public float SEGA_LOGO_startTimer;
        [FieldOffset(44)] public float SEGA_LOGO_endTimer;
        [FieldOffset(48)] public float SONICTEAM_LOGO_autoTimer;
        [FieldOffset(52)] public float SONICTEAM_LOGO_skipTimer;
        [FieldOffset(56)] public float SONICTEAM_LOGO_startTimer;
        [FieldOffset(60)] public float SONICTEAM_LOGO_endTimer;
        [FieldOffset(64)] public float RSDK_CRI_LOGO_autoTimer;
        [FieldOffset(68)] public float RSDK_CRI_LOGO_skipTimer;
        [FieldOffset(72)] public float RSDK_CRI_LOGO_startTimer;
        [FieldOffset(76)] public float RSDK_CRI_LOGO_endTimer;
    }

    [StructLayout(LayoutKind.Explicit, Size = 12)]
    public struct TitleRflParam
    {
        [FieldOffset(0)] public float toMovieTimer;
        [FieldOffset(4)] public float movieVolume;
        [FieldOffset(8)] public float cancelInputTime;
    }

    [StructLayout(LayoutKind.Explicit, Size = 12)]
    public struct OptionLanguageEditRflParam
    {
        [FieldOffset(0)] public unsafe fixed bool enableEdit[12];
    }

    [StructLayout(LayoutKind.Explicit, Size = 120)]
    public struct OptionLetterBoxEditRflParam
    {
        [FieldOffset(0)]  public unsafe fixed int enableDLC1LetterBoxKinds[10];
        [FieldOffset(40)] public unsafe fixed int enableDLC2LetterBoxKinds[20];
    }

    [StructLayout(LayoutKind.Explicit, Size = 16)]
    public struct CString
    {
        [FieldOffset(0)] public long pValue;

        public string Value
        {
        	get => Marshal.PtrToStringAnsi((IntPtr)pValue);
        	set => pValue = (long)Marshal.StringToHGlobalAnsi(value);
        }
    }

    [StructLayout(LayoutKind.Explicit, Size = 72)]
    public struct OptionLicensePFParam
    {
        [FieldOffset(0)]  public CString addText;
        [FieldOffset(16)] public int addTextSize;
        [FieldOffset(24)] public CString addCommonTagJP;
        [FieldOffset(40)] public CString addCommonTagUS;
        [FieldOffset(56)] public CString addCommonTagEU;
    }

    [StructLayout(LayoutKind.Explicit, Size = 368)]
    public struct OptionLicenseRflParam
    {
        [FieldOffset(0)]   public int commonTextSize;
        [FieldOffset(8)]   public OptionLicensePFParam licensePS;
        [FieldOffset(80)]  public OptionLicensePFParam licenseXBOX;
        [FieldOffset(152)] public OptionLicensePFParam licenseSWITCH;
        [FieldOffset(224)] public OptionLicensePFParam licenseSTEAM;
        [FieldOffset(296)] public OptionLicensePFParam licenseEPIC;
    }

    [StructLayout(LayoutKind.Explicit, Size = 520)]
    public struct OptionRflParam
    {
        [FieldOffset(0)]   public OptionLanguageEditRflParam languageEdit;
        [FieldOffset(12)]  public OptionLetterBoxEditRflParam letterBoxEdit;
        [FieldOffset(136)] public OptionLicenseRflParam licenseParam;
        [FieldOffset(504)] public int ui_seekbarActionMove;
        [FieldOffset(508)] public float ui_seekbarWheelRatio;
        [FieldOffset(512)] public int applyTimer;
    }

    [StructLayout(LayoutKind.Explicit, Size = 4)]
    public struct SaveIconRflParam
    {
        [FieldOffset(0)] public float minimumDisplayTime;
    }

    [StructLayout(LayoutKind.Explicit, Size = 712)]
    public struct Root
    {
        [FieldOffset(0)]   public MenuRflParam menuParam;
        [FieldOffset(88)]  public AdvertiseRflParam advertiseParam;
        [FieldOffset(168)] public TitleRflParam titleParam;
        [FieldOffset(184)] public OptionRflParam optionParam;
        [FieldOffset(704)] public SaveIconRflParam saveIconParam;
    }

}
Patch "Disable Auto Save Icon" in "UI" by "Hyper" 
{
    WriteProtected<byte>
    (
        // v1.0.0: 0x140403FAC
        ScanSignature
        (
            "\x48\x89\x5C\x24\x00\x48\x89\x74\x24\x00\x48\x89\x7C\x24\x00\x55\x48\x8D\x6C\x24\x00\x48\x81\xEC\x00\x00\x00\x00\x48\x8B\xDA\x48\x8B\xF9\xE8\x00\x00\x00\x00\x48\x8B\xD0\x48\x8B\xCB\xE8\x00\x00\x00\x00\x33\xF6\x48\x85\xC0\x74\x16\x48\x85\xFF\x48\x8D\x97\x00\x00\x00\x00\x48\x8B\xC8\x48\x0F\x44\xD6\xE8\x00\x00\x00\x00\x0F\x57\xC0\xC7\x45\x00\x00\x00\x00\x00\x48\x8D\x8F\x00\x00\x00\x00\xC6\x45\xBB\x80\xF3\x0F\x7F\x45\x00\x48\xC7\x45\x00\x00\x00\x00\x00\x48\xC7\x45\x00\x00\x00\x00\x00\x89\x75\xCF\xE8\x00\x00\x00\x00\x48\x8B\x15\x00\x00\x00\x00\x48\x8D\x4D\xA7\x48\x89\x45\xAF\xC7\x45\x00\x00\x00\x00\x00\xC6\x45\xBB\x15\xE8\x00\x00\x00\x00\xE8\x00\x00\x00\x00\x48\x8B\xD0\x48\x8B\xCF\xE8\x00\x00\x00\x00\x48\x8B\xD8",
            "xxxx?xxxx?xxxx?xxxxx?xxx????xxxxxxx????xxxxxxx????xxxxxxxxxxxxx????xxxxxxxx????xxxxx?????xxx????xxxxxxxx?xxx?????xxx?????xxxx????xxx????xxxxxxxxxx?????xxxxx????x????xxxxxxx????xxx"
        )
        + 0x1C,

        0xE9, 0x94, 0x01, 0x00, 0x00
    );
}



Code "Disable Super Music" in "Audio/Sonic 3 & Knuckles" by "MegAmi" does "Due to how the cheat works, the Super music may still play in some instances, such as after the AIZ Act 1 bombing cutscene." 
//
    #lib "RSDK"
//
{
    if (RSDK.GetRSDKGlobalsAbsPtr() == 0)
        return;
    
    WriteProtected<byte>(RSDK.GetRSDKGlobalsAbsPtr() - 0x08, 0x00);
}


Patch "Restore Print Function" in "Debug/RSDKv4" by "SuperSonic16" does "Reimplements the Print function back into the RSDKv4 scripting system."
{
    #include "Helpers" noemit
    #lib "Memory"
    using System.Runtime.InteropServices;

    // 2.0.2: 0x1400CF79B
    long ProcessScriptv4_FUNC_PRINT = ScanSignature(
        "\x45\x33\xD2\x45\x8B\xEA\x4C\x8D\x15\x00\x00\x00\x00\xE9\x00\x00\x00\x00\x44\x8B\x05\x00\x00\x00\x00\x48\x8D\x0D\x00\x00\x00\x00\x44\x8B\x0D\x00\x00\x00\x00\x33\xC0\x41\x83\xF8\x01\x8B\xD7",
        "xxxxxxxxx????x????xxx????xxx????xxx????xxxxxxxx");

    long scriptEng_addr = (long)Memory.ReadEffectiveAddress(ProcessScriptv4_FUNC_PRINT + 0x12) - 0x08;
    long scriptText_addr = (long)Memory.ReadEffectiveAddress(ProcessScriptv4_FUNC_PRINT + 0x19);

    class ConsoleHelper
    {
        
        UNMANAGED_FUNCTION(void, Print, string scriptText, int* param, int opcode)
        {
            if (opcode != 0x8A)
                return;

            int val = param[0];
            bool isInt = param[1] != 0;
            bool isNewLine = param[2] != 0;

            string suffix = isNewLine ? "\n" : "";
            if (isInt)
                Console.Write($"[RSDKv4] {val}{suffix}");
            else
                Console.Write($"[RSDKv4] {scriptText}{suffix}");
        }
    }

    WriteAsmHook
        (
            $@"
                sub rsp, 32
                mov r8, rax
                mov rdx, {scriptEng_addr}
                mov rcx, {scriptText_addr}
                mov rax, {ConsoleHelper._fpPrint}
                call rax
                add rsp, 32
                mov  rax, {ProcessScriptv4_FUNC_PRINT - 0x0139}
                jmp rax
            ",
            ProcessScriptv4_FUNC_PRINT,
            HookBehavior.Replace
        );
}

Patch "Enable Debug Mode" in "Debug/Sonic 3 & Knuckles" by "SuperSonic16" does "Enables Debug Mode in Sonic 3 & Knuckles on stage load."
{
    // 2.0.1: 0x1401E5BE2
    // mov ecx,00000001
    WriteProtected<byte>(
        ScanSignature
        (
            "\x8B\x88\x00\x00\x00\x00\x41\xBE\x00\x00\x00\x00\x48\x8B\x05\x00\x00\x00\x00\x83\xE1\x01\x45\x33\xC9\x44\x89\x74\x24\x00",
            "xx????xx????xxx????xxxxxxxxxx?"
        ),
        0xB9, 0x01, 0x00, 0x00, 0x00, 0x90);
}

Code "30 FPS Frontend" in "Graphics/FPS" by "MegAmi" does
/*
Limits the main menu to running at 30 FPS.

This works similarly to how the Switch version's FPS cap works, meaning the actual games are unaffected.
*/
//
	#include "ReflectionHelpers" noemit

	#lib "UIRflParam"
//
{
	var UIRflParamInfo = Reflection.GetDataInfo<UIRflParam.Root>("ui_rfl_param");

	if (UIRflParamInfo.pData == null)
		return;

	RFL_SET_PARAM(UIRflParamInfo, menuParam.fpsParam.isFPS30, true);
}
Patch "Enable Extended Timer" in "UI/Sonic 3 & Knuckles" by "SuperSonic16" does "Enables the extended timer similar to what is used in Sonic Mania, Sonic CD and time attack."
{
    // 0x1401CE6DE + 0x15
    long HUD_Create_3E3 = ScanSignature(
        "\xFF\x90\x00\x00\x00\x00\x48\x8B\xCB\xE8\x00\x00\x00\x00\x48\x8B\x05\x00\x00\x00\x00\x48\x8D\x53\x5D\x45\x33\xC9\xC7\x44\x24\x00\x00\x00\x00\x00\x45\x33\xC0\x48\x8D\x0D\x00\x00\x00\x00\xFF\x90\x00\x00\x00\x00\x48\x8B\x7C\x24\x00\x48\x8B\x74\x24\x00\x48\x83\xC4\x30\x5B\xC3",
        "xx????xxxx????xxx????xxxxxxxxxx?????xxxxxx????xx????xxxx?xxxx?xxxxxx") + 0x15;

    WriteAsmHook
    (
        "mov byte ptr [rbx+0x338], 1",
        HUD_Create_3E3,
        HookBehavior.Before
    );
}

