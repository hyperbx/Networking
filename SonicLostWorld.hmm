Library "Bitwise" by "Hyper" 
{
    public long Set(long in_base, int in_offset, bool in_isOffsetBitIndex = true)
    {
        return in_base | (in_isOffsetBitIndex ? (1L << in_offset) : in_offset);
    }

    public long Reset(long in_base, int in_offset, bool in_isOffsetBitIndex = true)
    {
        return in_base & (in_isOffsetBitIndex ? ~(1L << in_offset) : in_offset);
    }

    public bool Test(long in_base, int in_offset, bool in_isOffsetBitIndex = true)
    {
        return (in_base & (in_isOffsetBitIndex ? (1L << in_offset) : in_offset)) != 0;
    }
}
Library "HMM" by "Hyper"
{
    #lib "INI"

    using System.Collections.Generic;
    using System.IO;

    public Dictionary<string, Dictionary<string, string>> GetModsDatabase()
    {
        string workingDir = Directory.GetCurrentDirectory();
        string cpkredirCfgPath = Path.Combine(workingDir, "cpkredir.ini");

        if (!File.Exists(cpkredirCfgPath))
            return new();

        var cpkredirCfg = INI.Read(cpkredirCfgPath);
        string modsDbPath = cpkredirCfg["CPKREDIR"]["ModsDbIni"];

        if (!File.Exists(modsDbPath))
            return new();

        return INI.Read(modsDbPath);
    }

    public List<Mod> GetMods()
    {
        List<Mod> result = new();

        var modsDb = GetModsDatabase();

        if (modsDb == null)
            return result;

        int activeModCount = INI.Parse<int>(modsDb["Main"]["ActiveModCount"], 0);

        foreach (var entry in modsDb["Mods"].Keys)
        {
            for (int i = 0; i < activeModCount; i++)
            {
                if (modsDb["Main"][$"ActiveMod{i}"].Contains(entry))
                {
                    result.Add(new Mod(modsDb["Mods"][entry]));
                }
            }
        }

        return result;
    }

    public Mod GetModByID(string in_id)
    {
        foreach (var mod in GetMods())
        {
            if (mod.ID == in_id)
                return mod;
        }

        return null;
    }

    public List<Mod> FindModsByName(string name)
    {
        List<Mod> result = new();

        foreach (var mod in GetMods())
        {
            if (mod.Name.Contains(name))
            {
                result.Add(mod);
            }
        }

        return result;
    }

    public List<string> GetCodes()
    {
        List<string> result = new();

        var modsDb = GetModsDatabase();

        if (modsDb == null)
            return result;

        foreach (var value in modsDb["Codes"].Values)
            result.Add(value);

        return result;
    }

    public class Mod
    {
        public string Name { get; set; } = string.Empty;

        public string Version { get; set; } = string.Empty;

        public string Author { get; set; } = string.Empty;

        public string Description { get; set; } = string.Empty;

        public string Date { get; set; } = string.Empty;

        public string AuthorURL { get; set; } = string.Empty;

        public string UpdateServer { get; set; } = string.Empty;

        public string SaveFile { get; set; } = string.Empty;

        public string ID { get; set; } = string.Empty;

        public List<string> IncludeDirs { get; set; } = new();

        public List<ModDependency> Dependencies { get; set; } = new();

        public string DLLFile { get; set; } = string.Empty;

        public string CodeFile { get; set; } = string.Empty;

        public string ConfigSchemaFile { get; set; } = string.Empty;

        public string Path { get; set; } = string.Empty;

        public Dictionary<string, Dictionary<string, string>> Ini { get; set; } = new();

        public Mod(string modIniPath)
        {
            var ini = INI.Read(modIniPath);

            if (ini == null)
                return;

            Name             = INI.GetField<string>(ini, "Desc", "Title", Name);
            Version          = INI.GetField<string>(ini, "Desc", "Version", Version);
            Author           = INI.GetField<string>(ini, "Desc", "Author", Author);
            Description      = INI.GetField<string>(ini, "Desc", "Description", Description);
            Date             = INI.GetField<string>(ini, "Desc", "Date", Date);
            AuthorURL        = INI.GetField<string>(ini, "Desc", "AuthorURL", AuthorURL);
            UpdateServer     = INI.GetField<string>(ini, "Main", "UpdateServer", UpdateServer);
            SaveFile         = INI.GetField<string>(ini, "Main", "SaveFile", SaveFile);
            ID               = INI.GetField<string>(ini, "Main", "ID", ID);
            DLLFile          = INI.GetField<string>(ini, "Main", "DLLFile", DLLFile);
            CodeFile         = INI.GetField<string>(ini, "Main", "CodeFile", CodeFile);
            ConfigSchemaFile = INI.GetField<string>(ini, "Main", "ConfigSchemaFile", ConfigSchemaFile);

            Path             = System.IO.Path.GetDirectoryName(modIniPath);
            Ini              = ini;

            int includeDirCount = INI.GetField<int>(ini, "Main", "IncludeDirCount", 1);

            for (int i = 0; i < includeDirCount; i++)
                IncludeDirs.Add(INI.GetField<string>(ini, "Main", $"IncludeDir{i}", "."));

            int dependencyCount = INI.GetField<int>(ini, "Main", "DependsCount", 0);

            for (int i = 0; i < dependencyCount; i++)
                Dependencies.Add(new ModDependency(INI.GetField<string>(ini, "Main", $"Depends{i}", "")));
        }
    }

    public class ModDependency
    {
        public string ID { get; set; }

        public string Name { get; set; }
        
        public string Link { get; set; }

        public string Version { get; set; }

        public ModDependency(string in_id, string in_name, string in_link, string in_version)
        {
            ID = in_id;
            Name = in_name;
            Link = in_link;
            Version = in_version;
        }

        public ModDependency(string in_csv)
        {
            var fields = in_csv.Split('|');

            for (int i = 0; i < fields.Length; i++)
            {
                switch (i)
                {
                    case 0:
                        ID = fields[i];
                        break;

                    case 1:
                        Name = fields[i];
                        break;

                    case 2:
                    {
                        if (fields.Length > 2)
                        {
                            Link = fields[i];
                        }
                        else
                        {
                            Version = fields[i];
                        }

                        break;
                    }

                    case 3:
                        Version = fields[i];
                        break;
                }
            }
        }
    }
}
Library "INI" by "Hyper"
{
    using System.Collections.Generic;
    using System.IO;
    
    public Dictionary<string, Dictionary<string, string>> Read(string path)
    {
        Dictionary<string, Dictionary<string, string>> result = new();

        if (!File.Exists(path))
            return result;

        using (StreamReader reader = new StreamReader(path))
        {
            string section = string.Empty;
            string line = string.Empty;

            // Add root section.
            result.Add(section, new Dictionary<string, string>());

            while ((line = reader.ReadLine()) != null)
            {
                if (line.StartsWith("[") && line.EndsWith("]"))
                {
                    section = line.Substring(1, line.Length - 2);
                    result.Add(section, new Dictionary<string, string>());
                    continue;
                }

                if (line.StartsWith(";") || line.StartsWith("#"))
                    continue;

                int delimiterIndex = line.IndexOf('=');

                if (delimiterIndex == -1)
                    continue;

                string key = line.Substring(0, delimiterIndex);
                string value = line.Substring(delimiterIndex + 1);

                if (value.StartsWith("\"") && value.EndsWith("\"") && value.Length > 1)
                    value = value.Substring(1, value.Length - 2);
                
                result[section].Add(key, value);
            }
        }

        return result;
    }

    public T Parse<T>(string in_value, T in_defaultValue)
    {
        T result = in_defaultValue;

        if (typeof(T) == typeof(string))
        {
            result = (T)(object)in_value;
        }
        else if (typeof(T) == typeof(int))
        {
            if (int.TryParse(in_value, out int intValue))
            {
                result = (T)(object)intValue;
            }
        }
        else if (typeof(T) == typeof(double))
        {
            if (double.TryParse(in_value, out double doubleValue))
            {
                result = (T)(object)doubleValue;
            }
        }
        else if (typeof(T) == typeof(float))
        {
            if (float.TryParse(in_value, out float floatValue))
            {
                result = (T)(object)floatValue;
            }
        }

        return result;
    }

    public T GetField<T>(Dictionary<string, Dictionary<string, string>> in_ini, string in_section, string in_key, T in_defaultValue)
    {
        if (!in_ini.ContainsKey(in_section))
            return in_defaultValue;

        if (!in_ini[in_section].ContainsKey(in_key))
            return in_defaultValue;

        return Parse<T>(in_ini[in_section][in_key], in_defaultValue);
    }
}
Library "Logger" by "Hyper"
{
    #define PRINT_OBJECT(obj, format, caller) Logger.Utility(#obj + " = " + obj.ToString(format), caller);
    #define PRINT_OBJECT(obj, format) Logger.Utility(#obj + " = " + obj.ToString(format));

    public enum LogLevel
    {
        None,
        Utility,
        Warning,
        Error
    }

    public void Log(object message, LogLevel level = LogLevel.None, string caller = "")
    {
        var oldColour = Console.ForegroundColor;

        switch (level)
        {
            case LogLevel.Warning:
                Console.ForegroundColor = ConsoleColor.Yellow;
                break;

            case LogLevel.Error:
                Console.ForegroundColor = ConsoleColor.Red;
                break;

            case LogLevel.Utility:
                Console.ForegroundColor = ConsoleColor.Green;
                break;
        }

        Console.WriteLine(string.IsNullOrEmpty(caller) ? message.ToString() : $"[{caller}] {message}");

        Console.ForegroundColor = oldColour;
    }

    public void Utility(object message, string caller = "")
    {
        Log(message, LogLevel.Utility, caller);
    }

    public void Warning(object message, string caller = "")
    {
        Log(message, LogLevel.Warning, caller);
    }

    public void Error(object message, string caller = "")
    {
        Log(message, LogLevel.Error, caller);
    }
}
Library "MathHelpers" by "Hyper" 
{
    using System.Collections.Generic;

    public T Clamp<T>(T in_value, T in_minValue, T in_maxValue) where T : IComparable<T>
    {
        if (in_value.CompareTo(in_minValue) < 0)
        {
            return in_minValue;
        }
        else if (in_value.CompareTo(in_maxValue) > 0)
        {
            return in_maxValue;
        }
        else
        {
            return in_value;
        }
    }

    public T Clamp01<T>(T value) where T : IComparable<T>
    {
        if (value.CompareTo(default(T)) < 0)
        {
            return default(T);
        }
        else if (value.CompareTo((T)Convert.ChangeType(1, typeof(T))) > 0)
        {
            return (T)Convert.ChangeType(1, typeof(T));
        }
        else
        {
            return value;
        }
    }

    public T FloatPercentToRange<T>(float in_value)
    {
        if (typeof(T) == typeof(sbyte))
        {
            return (T)(object)(byte)(in_value * (sbyte.MaxValue * 1.0f));
        }
        else if (typeof(T) == typeof(byte))
        {
            return (T)(object)(byte)(in_value * (byte.MaxValue * 1.0f));
        }
        else if (typeof(T) == typeof(short))
        {
            return (T)(object)(short)(in_value * (short.MaxValue * 1.0f));
        }
        else if (typeof(T) == typeof(ushort))
        {
            return (T)(object)(ushort)(in_value * (ushort.MaxValue * 1.0f));
        }
        else if (typeof(T) == typeof(int))
        {
            return (T)(object)(int)(in_value * (int.MaxValue * 1.0f));
        }
        else if (typeof(T) == typeof(uint))
        {
            return (T)(object)(uint)(in_value * (uint.MaxValue * 1.0f));
        }
        else if (typeof(T) == typeof(long))
        {
            return (T)(object)(long)(in_value * (long.MaxValue * 1.0f));
        }
        else if (typeof(T) == typeof(ulong))
        {
            return (T)(object)(ulong)(in_value * (ulong.MaxValue * 1.0f));
        }
        
        return default;
    }
    
    public float Lerp(float in_start, float in_end, float in_time)
    {
        return in_start + (in_end - in_start) * in_time;
    }

    public static float InverseLerp(float a, float b, float value)
    {
        if (a == b)
            return 0.0f;

        return Clamp01<float>((value - a) / (b - a));
    }

    public static float ToDegrees(float in_radians)
    {
        return in_radians * (180.0f / (float)Math.PI);
    }

    public static float ToRadians(float in_degrees)
    {
        return in_degrees * ((float)Math.PI / 180.0f);
    }

    public static float WrapToRadians(float in_value)
    {
        float sign = in_value > 0.0f ? 1.0f : -1.0f;
        float mod = (float)Math.Abs(in_value) % 6.28319f;

        return mod * sign;
    }
}
Library "Memory" by "Hyper & Sajid" 
{
    using System.Collections.Generic;
    using System.Runtime.InteropServices;
    using System.Runtime.CompilerServices;
    using System.Text;

    private static Dictionary<nint, List<byte>> _preservedMemory = new();

    public void Preserve(nint in_location, nint in_length, bool in_isPreservedOnce = true)
    {
        if (in_location == 0)
            return;

        if (in_isPreservedOnce)
        {
            if (_preservedMemory.ContainsKey(in_location))
                return;
        }
        else
        {
            if (_preservedMemory.ContainsKey(in_location))
                _preservedMemory.Remove(in_location);
        }
        
        List<byte> buffer = new();
        for (nint i = 0; i < in_length; i++)
            buffer.Add(Read<byte>(in_location + i));

        _preservedMemory.Add(in_location, buffer);
    }

    public void Preserve(long in_location, long in_length, bool in_isPreservedOnce = true)
    {
        Preserve((nint)in_location, (nint)in_length, in_isPreservedOnce);
    }

    public void Restore(nint in_location)
    {
        if (in_location == 0)
            return;

        if (!_preservedMemory.ContainsKey(in_location))
            return;

        nint i = 0;
        foreach (byte b in _preservedMemory[in_location])
        {
            WriteProtected<byte>(in_location + i, b);
            i++;
        }
    }

    public void Restore(long in_location)
    {
        Restore((nint)in_location);
    }

    public nint ReadCall(nint in_location)
    {
        if (in_location == 0)
            return 0;

        return in_location + Read<int>(in_location + 0x01) + 0x05;
    }

    public long ReadCall(long in_location)
    {
        return (long)ReadCall((nint)in_location);
    }

    public nint ReadEffectiveAddress(nint in_location)
    {
        if (in_location == 0)
            return 0;

        return in_location + Read<int>(in_location + 0x03) + 0x07;
    }

    public long ReadEffectiveAddress(long in_location)
    {
        return (long)ReadEffectiveAddress((nint)in_location);
    }

    public enum JumpType : sbyte
    {
        Unknown = -1,
        ShortCond,
        NearJmp,
        NearCond,
        LongJmp
    }

    public JumpType ReadJumpOpcode(nint in_location)
    {
        JumpType result = JumpType.Unknown;

        if (in_location == 0)
            return result;

        byte opcode = Read<byte>(in_location);

        if ((opcode & 0xF0) == 0x70)
        {
            result = JumpType.ShortCond;
        }
        else
        {
            switch (opcode)
            {
                case 0xE3:
                case 0xEB:
                    result = JumpType.ShortCond;
                    break;

                case 0xE9:
                    result = JumpType.NearJmp;
                    break;

                case 0x0F:
                    result = JumpType.NearCond;
                    break;

                case 0xFF:
                    result = JumpType.LongJmp;
                    break;
            }
        }

        return result;
    }

    public JumpType ReadJumpOpcode(long in_location)
    {
        return ReadJumpOpcode((nint)in_location);
    }

    public nint ReadJump(nint in_location)
    {
        if (in_location == 0)
            return 0;

        switch (ReadJumpOpcode(in_location))
        {
            case JumpType.ShortCond:
                return in_location + Read<byte>(in_location + 0x01) + 0x02;

            case JumpType.NearJmp:
                return in_location + Read<int>(in_location + 0x01) + 0x05;

            case JumpType.NearCond:
                return in_location + Read<int>(in_location + 0x02) + 0x06;

            case JumpType.LongJmp:
                return (nint)Read<long>(in_location + 0x06);
        }

        return 0;
    }

    public long ReadJump(long in_location)
    {
        return (long)ReadJump((nint)in_location);
    }

    public void WriteForceJump(nint in_location)
    {
        if (in_location == 0)
            return;
        
        switch (ReadJumpOpcode(in_location))
        {
            case JumpType.ShortCond:
                WriteProtected<byte>(in_location, 0xEB);
                break;

            case JumpType.NearCond:
                WriteProtected<byte>(in_location, 0xE9);
                WriteProtected<int>(in_location + 0x01, Read<int>(in_location + 0x02) + 0x01);
                break;
        }
    }

    public void WriteForceJump(long in_location)
    {
        WriteForceJump((nint)in_location);
    }

    public nint ReadThunk(nint in_location, nint in_offset = 0)
    {
        return ReadJump(ReadCall(in_location) + in_offset);
    }

    public long ReadThunk(long in_location, long in_offset = 0)
    {
        return (long)ReadThunk((nint)in_location, (nint)in_offset);
    }

    public void WriteString(long in_location, string in_str, Encoding in_encoding)
    {
        WriteProtected<byte>(in_location, in_encoding.GetBytes(in_str));
    }

    public void WriteString(long in_location, string in_str)
    {
        WriteString(in_location, in_str, Encoding.ASCII);
    }

    public void PrintMemory<T>(IntPtr in_address, int in_rowCount) where T : unmanaged
    {
        for (int i = 0; i < in_rowCount * 16; i += 16)
        {
            Console.Write($"{(in_address + i).ToInt64():X16}: ");

            if (typeof(T) == typeof(byte) || typeof(T) == typeof(sbyte))
            {
                for (int j = 0; j < 16; j++)
                    Console.Write($"{Read<T>(in_address + i + j):X2} ");
            }
            else if (typeof(T) == typeof(short) || typeof(T) == typeof(ushort))
            {
                for (int j = 0; j < 16; j += 2)
                    Console.Write($"{Read<T>(in_address + i + j):X4} ");
            }
            else if (typeof(T) == typeof(int) || typeof(T) == typeof(uint))
            {
                for (int j = 0; j < 16; j += 4)
                    Console.Write($"{Read<T>(in_address + i + j):X8} ");
            }
            else if (typeof(T) == typeof(long) || typeof(T) == typeof(ulong))
            {
                for (int j = 0; j < 16; j += 8)
                    Console.Write($"{Read<T>(in_address + i + j):X16} ");
            }
            else if (typeof(T) == typeof(float))
            {
                for (int j = 0; j < 16; j += 4)
                    Console.Write($"{Read<float>(in_address + i + j)} ");
            }
            else if (typeof(T) == typeof(double))
            {
                for (int j = 0; j < 16; j += 8)
                    Console.Write($"{Read<double>(in_address + i + j)} ");
            }

            Console.WriteLine();
        }
    }

    public void PrintMemory(IntPtr in_address, int in_rowCount)
    {
        PrintMemory<byte>(in_address, in_rowCount);
    }
    
    public struct Pointer<T> where T : unmanaged
    {
        public T* pData;

        public Pointer(ref T data)
        {
            fixed(T* dataPtr = &data)
            {
                pData = dataPtr;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Pointer(T* in_pData)
        {
            pData = in_pData;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsValid()
        {
            return pData != null;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T Ref()
        {
            return ref *pData;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T* Get()
        {
            return pData;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator bool(Pointer<T> self) => self.IsValid();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator Pointer<T>(T* data) => new(data);

        public override string ToString() => $"0x{((long)pData):X}";
    }
}
Library "VectorHelpers" by "Hyper" 
{
    #load "System.Numerics.dll"

    using System.Numerics;

    public static Vector3 ClampMagnitude(Vector3 in_vector, float in_maxMagnitude)
    {
        if (in_vector.Length() > in_maxMagnitude * in_maxMagnitude)
            return Vector3.Normalize(in_vector) * in_maxMagnitude;

        return in_vector;
    }

    public static Vector3 GetForward(Quaternion in_rotation)
    {
        return Vector3.Transform(Vector3.UnitZ, Quaternion.Normalize(in_rotation));
    }

    public static float GetMagnitude(Vector3 in_velocity)
    {
        return in_velocity.Length();
    }

    public static float GetHorizontalMagnitude(Vector3 in_velocity)
    {
        return (float)Math.Sqrt(in_velocity.X * in_velocity.X + in_velocity.Z * in_velocity.Z);
    }

    public static float GetVerticalMagnitude(Vector3 in_velocity)
    {
        return in_velocity.Y;
    }

    public static Quaternion LookRotation(Vector3 in_forward, Vector3 in_upward)
    {
        in_forward = Vector3.Normalize(in_forward);
        in_upward = Vector3.Normalize(in_upward);

        var right = Vector3.Cross(in_upward, in_forward);
        in_upward = Vector3.Cross(in_forward, right);

        var m = new Matrix4x4
        (
            right.X,      right.Y,      right.Z,      0.0f,
            in_upward.X,  in_upward.Y,  in_upward.Z,  0.0f,
            in_forward.X, in_forward.Y, in_forward.Z, 0.0f,
            0.0f,         0.0f,         0.0f,         1.0f
        );

        return Quaternion.CreateFromRotationMatrix(m);
    }

    public static Quaternion LookRotation(Vector3 in_forward)
    {
        return LookRotation(in_forward, Vector3.UnitY);
    }
}
Library "XInput" by "Hyper" 
{
    #lib "MathHelpers"

    #load "System.Numerics.dll"

    using System.Numerics;
    using System.Runtime.InteropServices;

    [DllImport("xinput1_4.dll", EntryPoint = "XInputGetState")]
    public extern int XInputGetState(int in_dwUserIndex, ref State in_pState);
    
    [DllImport("xinput1_4.dll", EntryPoint = "XInputSetState")]
    public extern int XInputSetState(int in_dwUserIndex, ref Vibration in_pVibration);

    public const short XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE = 7849;
    public const short XINPUT_GAMEPAD_RIGHT_THUMB_DEADZONE = 8689;

    private static float _leftMotorSpeed = 0.0f;
    private static float _rightMotorSpeed = 0.0f;

    [Flags]
    public enum Buttons : ushort
    {
        DPAD_UP        = 0x0001,
        DPAD_DOWN      = 0x0002,
        DPAD_LEFT      = 0x0004,
        DPAD_RIGHT     = 0x0008,
        START          = 0x0010,
        BACK           = 0x0020,
        LEFT_THUMB     = 0x0040,
        RIGHT_THUMB    = 0x0080,
        LEFT_SHOULDER  = 0x0100,
        RIGHT_SHOULDER = 0x0200,
        A              = 0x1000,
        B              = 0x2000,
        X              = 0x4000,
        Y              = 0x8000
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct State
    {
        public int dwPacketNumber;
        public Gamepad Gamepad;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct Gamepad
    {
        public Buttons wButtons;
        public byte bLeftTrigger;
        public byte bRightTrigger;
        public short sThumbLX;
        public short sThumbLY;
        public short sThumbRX;
        public short sThumbRY;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct Vibration
    {
        public ushort wLeftMotorSpeed;
        public ushort wRightMotorSpeed;

        public Vibration(ushort in_leftMotorSpeed, ushort in_rightMotorSpeed)
        {
            wLeftMotorSpeed = in_leftMotorSpeed;
            wRightMotorSpeed = in_rightMotorSpeed;

            _leftMotorSpeed = in_leftMotorSpeed / 65535.0f;
            _rightMotorSpeed = in_rightMotorSpeed / 65535.0f;
        }

        public Vibration(float in_leftMotorSpeed, float in_rightMotorSpeed)
        {
            wLeftMotorSpeed = MathHelpers.FloatPercentToRange<ushort>(in_leftMotorSpeed);
            wRightMotorSpeed = MathHelpers.FloatPercentToRange<ushort>(in_rightMotorSpeed);

            _leftMotorSpeed = in_leftMotorSpeed;
            _rightMotorSpeed = in_rightMotorSpeed;
        }

        public Vibration(ushort in_motorSpeed)
        {
            wLeftMotorSpeed = wRightMotorSpeed = in_motorSpeed;
            _leftMotorSpeed = _rightMotorSpeed = in_motorSpeed / 65535.0f;
        }

        public Vibration(float in_motorSpeed)
        {
            wLeftMotorSpeed = wRightMotorSpeed = MathHelpers.FloatPercentToRange<ushort>(in_motorSpeed);
            _leftMotorSpeed = _rightMotorSpeed = in_motorSpeed;
        }
    }

    public State? GetState()
    {
        var pState = new State();

        if (XInputGetState(0, ref pState) != 0)
            return null;

        return pState;
    }

    public void SetState(Vibration in_vibration)
    {
        XInputSetState(0, ref in_vibration);
    }

    public Vector2 GetAnalog(int in_analogIndex, bool in_isTestDeadzone = true)
    {
        var pState = GetState();

        if (pState == null)
            return Vector2.Zero;

        Vector2 v = Vector2.Zero;

        switch (in_analogIndex)
        {
            case 0:
                v = new Vector2(pState.Value.Gamepad.sThumbLX / 32767.0f, pState.Value.Gamepad.sThumbLY / 32767.0f);
                break;

            case 1:
                v = new Vector2(pState.Value.Gamepad.sThumbRX / 32767.0f, pState.Value.Gamepad.sThumbRY / 32767.0f);
                break;
        }

        if (in_isTestDeadzone)
        {
            v = IsAnalogNeutral(in_analogIndex)
                ? Vector2.Zero
                : v;
        }

        return v;
    }

    // Use Player.Input for keyboard parity!
    public bool IsButtonDown(Buttons in_buttons)
    {
        var pState = GetState();

        if (pState == null)
            return false;

        return (pState.Value.Gamepad.wButtons & in_buttons) != 0;
    }

    public float GetTrigger(int in_triggerIndex)
    {
        var pState = GetState();

        if (pState == null)
            return 0;

        switch (in_triggerIndex)
        {
            case 0:
                return pState.Value.Gamepad.bLeftTrigger / 255.0f;

            case 1:
                return pState.Value.Gamepad.bRightTrigger / 255.0f;
        }

        return 0;
    }

    public bool IsAnalogNeutral(int in_analogIndex)
    {
        var pState = GetState();

        if (pState == null)
            return true;

        switch (in_analogIndex)
        {
            case 0:
            {
                short x = pState.Value.Gamepad.sThumbLX;
                short y = pState.Value.Gamepad.sThumbLY;

                return x < XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE &&
                    x > -XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE &&
                    y < XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE &&
                    y > -XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE;
            }

            case 1:
            {
                short x = pState.Value.Gamepad.sThumbRX;
                short y = pState.Value.Gamepad.sThumbRY;

                return x < XINPUT_GAMEPAD_RIGHT_THUMB_DEADZONE &&
                    x > -XINPUT_GAMEPAD_RIGHT_THUMB_DEADZONE &&
                    y < XINPUT_GAMEPAD_RIGHT_THUMB_DEADZONE &&
                    y > -XINPUT_GAMEPAD_RIGHT_THUMB_DEADZONE;
            }
        }

        return true;
    }

    public Vibration GetVibration()
    {
        return new Vibration(_leftMotorSpeed, _rightMotorSpeed);
    }

    public void SetVibration(float in_value)
    {
        SetState(new Vibration(in_value));
    }

    public void SetVibration(int in_motorIndex, float in_value)
    {
        switch (in_motorIndex)
        {
            case 0:
            {
                SetState(new Vibration(in_value, _rightMotorSpeed));
                break;
            }

            case 1:
            {
                SetState(new Vibration(_leftMotorSpeed, in_value));
                break;
            }
        }
    }
}



Patch "Disable Super Music" in "Audio" by "Sajid" does "Prevents the Super Sonic theme from overwriting the stage music." 
WriteNop(ASLR(0x0091ABAD), 6)



Patch "Disable Voice Option Completely" in "Audio" by "M&M" does "Prevents any sound considered as 'Voice' from playing, which in result prevents the music from lowering in volume. This is preferable over lowering the 'Voice' volume to 0 in the game's settings." 
WriteNop(ASLR(0x004A3D82), 5)



Patch "Enable DLC Music in Battle Mode" in "Audio" by "ĐeäTh" does "Enables the level music of the DLC levels to play during the game's multiplayer mode." 
WriteNop(ASLR(0x0095B570), 6)



Patch "Always Replayable DLC Stages" in "Cheats" by "ĐeäTh" does "Disables the 100000 score requirement for unlocking the DLC levels once they are completed. Instead they will always stay on the world map." 
WriteNop(ASLR(0x0090D2BC), 2);
String code = $@"mov eax, {ASLR(0x0090D210)}
push 0
push 0
push 0
mov ecx, esi
call eax
mov eax, {ASLR(0x0090D210)}
push 0
push 0
push 1
mov ecx, esi
call eax
mov eax, {ASLR(0x0090D210)}
push 0
push 0
push 2
mov ecx, esi
call eax
mov ecx, [ebp+0xC]
mov eax, [ecx]
cmp eax, -4";
WriteAsmHook
(
    ASLR(0x00911F2D),
    HookBehavior.Replace,
    code
)

WriteAsmHook
(
    ASLR(0x00912332),
    HookBehavior.After,
    "mov edi, 1"
)
WriteProtected<byte>(ASLR(0x00912338), 0x57);
WriteProtected<byte>(ASLR(0x00912326), 0x6A, 0x00);
WriteNop(ASLR(0x0094594F), 12);



Patch "Disable Bomb Cart Instant Death" in "Cheats" by "ĐeäTh" 
WriteNop(ASLR(0x007D82A2), 3);



Patch "Disable Ring Loss" in "Cheats" by "Sajid" does "Disables the loss of rings upon being damaged by an enemy." 
WriteNop(ASLR(0x00866900), 2)



Patch "Infinite Bounce Attacks" in "Cheats" by "ĐeäTh" does "Disables the 3 times limit on the bounce attack." 
WriteNop(ASLR(0x008CA177), 4);



Patch "Fix Pull Switch Grip Height" in "Fixes" by "ĐeäTh" does "Fixes the position of Sonic's grip compared to the light switches found in Silent Forest Act 4." 
WriteProtected<float>(ASLR(0x00DF2D14), -10.5f)



Patch "Fix Rigid Bodies Falling Through Collision" in "Fixes" by "ĐeäTh & Darío" does "Fixes enemies falling through the collision of the level occasionally." 
static int p_updateBroadphaseAndResetCollisionInformationOfWarpedBody = (int)ASLR(0x00AED500);
static int p_setLinearVelocity = (int)ASLR(0x00B88220);

WriteAsmHook
(
    $@"mov eax, {p_setLinearVelocity}
    call eax
    mov edx, [esi+14h]
    mov edx, [edx+10h]
    push edx
    mov eax, {p_updateBroadphaseAndResetCollisionInformationOfWarpedBody}
    call eax
    add esp, 4",
    ASLR(0x004B974F), HookBehavior.Replace
)



Patch "Fix Sideways Wall Jump" in "Fixes" by "Sajid" 
WriteNop(ASLR(0x008C142C), 2)



Patch "Disable DLC Prizes" in "Gameplay" by "ĐeäTh" does "Disables the prizes given by the DLC levels (bomb wisp) upon completion." 
WriteNop(ASLR(0x0094595B), 12);
WriteNop(ASLR(0x00945630), 5);



Patch "Disable Lock-On" in "Gameplay" by "Sajid" does "Disables the player's ability to Homing Attack or Kick enemies and objects. Enabled for a few bosses to prevent softlocks."
WriteProtected<uint>(ASLR(0x00537D15), 0x5005)
WriteProtected<uint>(ASLR(0x0053AFD1), 0x1003)
WriteProtected<uint>(ASLR(0x005A8121), 0x1003)
WriteProtected<uint>(ASLR(0x005C7A91), 0x1003)
WriteProtected<uint>(ASLR(0x00587A71), 0x1003)
WriteProtected<uint>(ASLR(0x0059889A), 0x5005)
WriteProtected<uint>(ASLR(0x0058FDC1), 0x1003)
Patch "Disable Player Model Scaling" by "ĐeäTh" in "Graphics" does "Disables the scaling applied to Sonic's model during gameplay (includes a version of the 'Fix Pull Switch Grip Height' code in it, the use of the two together is unnecessary)." 
// Nop out the app::GOCVisualTransformed::SetLocalScale(0.9f, 0.9f, 0.9f); in app::Player::RegisterBodyModel()
WriteNop(ASLR(0x008FE046), 41);

// Adjust Spin Model Spin Scale
WriteProtected<float>(ASLR(0x00E03670), 1.5f * 1.0f / 0.9f, 1.5f * 1.0f / 0.9f, 1.5f * 1.0f / 0.9f)

// Adjust Grip Position for Light Switches in Silent Forest Act 4
WriteProtected<float>(ASLR(0x00DF2D14), -11.7f)


Patch "Enable Mouth Switching in 3D" in "Graphics" by "ĐeäTh" does "Enables the mouth switching to occur on the player anywhere instead of just in 2D sections."
{
    WriteNop(ASLR(0x008F263A), 2)
}
Patch "Invisible Cloak Sonic" in "Graphics" by "Muzzarino" does "Turns Sonic's textures into a highly reflective material to blend in (requires the Jump or Spin button to be pressed to enable it)." 
WriteNop(ASLR(0x0085C68E), 6)



Patch "Disable Wisp Hints" in "UI" by "Sajid" 
WriteNop(ASLR(0x0091AAF8), 6)



Patch "Enable Stage Retry Option" in "UI" by "Sajid" does "Enables the Retry option from the game's time attack mode in normal play." 
WriteAsmHook
(
    ASLR(0x005169E3),
    HookBehavior.After,
    "mov DWORD PTR [ebp+8], 1"
)



Patch "Traditional Countdown Timer" in "UI" by "ĐeäTh" does "Displays the timer in the typical 00:00.00 format instead of the 000 format found in the game. The timer's functionality is not changed." 
// Allow bigger time constraints to be displayed on HUD
WriteProtected<int>(ASLR(0x00501CC5), 3599);
WriteProtected<int>(ASLR(0x00501CCC), 3599);

// Lower Count Down Timer flashing red to 1 minute from 99 seconds
WriteProtected<byte>(ASLR(0x00501D31), 59);

// Remove check to only update the HUD if the seconds value changed
WriteNop(ASLR(0x00501CDE), 2);

static int ms_fpSnprintf = (int)ASLR(0x004047E0);
static int ms_pRetAddressCountDownUpdate = (int)ASLR(0x00501CF7);

static int ms_milliseconds = 0;
static string ms_format = "%02d:%02d.%02d";
static IntPtr ms_pFormat = System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(ms_format);

fixed(int* millisecondsPtr = &ms_milliseconds)
{
    // Calculate Milliseconds
    WriteAsmHook
    (
        $@"mov eax, [ebp - 0x3C]
        mov edx, 0
        mov ecx, 100
        div ecx
        sub ecx, edx
        cmp ecx, 100
        jne ignoreFallback
        mov ecx, 00

        ignoreFallback:
        mov [{(uint)millisecondsPtr}], ecx
        mov ecx, [ebx + 128h]",
        ASLR(0x0091685E), HookBehavior.Replace
    )

    // Change Display String for Count Down Timer
    WriteAsmHook
    (
        $@"mov eax, [{(uint)millisecondsPtr}]
        push eax
        mov edx, 0
        mov eax, edi
        mov ecx, 0x3C
        div ecx
        push edx
        push eax
        push {(uint)ms_pFormat}
        lea eax, [ebp - 44h]
        push 40h
        push eax
        mov [esi + 1B0h], edi
        mov eax, {ms_fpSnprintf}
        call eax
        add esp, 8
        mov eax, {ms_pRetAddressCountDownUpdate}
        jmp eax",
        ASLR(0x00501CE0), HookBehavior.Replace
    )
}



Patch "Fix Depth Effects on Intel GPUs" in "Fixes/Graphics" by "Skyth" 
WriteAsmHook(ASLR(0x00C2B233), HookBehavior.Replace, @"
mov eax, dword ptr [ebp + 8]

loop:
cmp dword ptr [eax], 0xFFFF
jz break

cmp dword ptr [eax], 0x3B7F0001
jnz continue
cmp dword ptr [eax + 4], 0x377F0001
jnz continue
cmp dword ptr [eax + 8], 0x3F7F0001
jnz continue

mov dword ptr [eax], 0x3F800000
mov dword ptr [eax + 4], 0
mov dword ptr [eax + 8], 0
jmp break

continue:
add eax, 4
jmp loop

break:
mov eax, [ecx + 0x64]
mov ecx, [eax]
");



Patch "Fix Depth of Field Draw Order" in "Fixes/Graphics" by "Sajid" does "Changes the pseudo-dof implementation of the game into the proper one seen on Wii U." 
static int p_DofRes = (int)ASLR(0x00FEFC7C);
static int p_GrassRes = (int)ASLR(0x00FB6D1C);
static int p_ShadowRes = (int)ASLR(0x00FB6D1D);
static int p_RetAddress = (int)ASLR(0x00904E94);

WriteAsmHook
(
    $@"mov BYTE PTR [edi+28Ch], 0
    movzx eax,byte ptr [{p_DofRes}]
    mov [edi+28Ch], al
    cmp byte ptr [{p_GrassRes}], 0
    sete cl
    mov [edi+49Ch], cl
    mov al, [{p_ShadowRes}]
    mov [edi+4F4h], al

    mov eax, {p_RetAddress}
    jmp eax",
    ASLR(0x00904E64), HookBehavior.Replace
)



Patch "Fix Parkour Trail Model" in "Fixes/Graphics" by "ĐeäTh & Sajid" does "Fixes hidden meshes (such as the secondary mouth mesh) being visible from the player's after image effect created by wallrunning."
{
WriteAsmHook
(
    $@"
        mov ecx, [esi+0x320]
        mov ecx, [ecx]
        mov eax, edi
        push ecx
        push eax
        call copyVisibilityFlags
        add esp, 8
        jmp originalReplace

    copyVisibilityFlags:
        push    ebp
        mov     ebp, esp
        push    ebx
        mov     ebx, [ebp+0xC]
        push    edi
        xor     edi, edi
        mov     ecx, [ebx+0xE0]
        mov     eax, [ecx+0x58]
        cmp     [eax+4], edi
        jbe     loc_10072B3C
        push    esi
        xor     esi, esi
        nop     dword ptr [eax+eax]

    loc_10072B00:
        mov     eax, [ecx+0x58]
        mov     ecx, [eax]
        lea     eax, [ecx+esi]
        neg     ecx
        sbb     ecx, ecx
        and     ecx, eax
        mov     eax, [ecx]
        mov     ecx, [ebp+8]
        mov     ecx, [ecx+0xE0]
        mov     ecx, [ecx+0x58]
        mov     edx, [ecx]
        lea     ecx, [edx+esi]
        neg     edx
        lea     esi, [esi+0x5C]
        sbb     edx, edx
        inc     edi
        and     edx, ecx
        mov     [edx], eax
        mov     ecx, [ebx+0xE0]
        mov     eax, [ecx+0x58]
        cmp     edi, [eax+4]
        jb      loc_10072B00
        pop     esi

    loc_10072B3C:
        pop     edi
        pop     ebx
        pop     ebp
        ret

    originalReplace:
        pop edi
        mov dword ptr [esi+0x320]
    ",
    ASLR(0x004CB4B6), HookBehavior.Replace
)
}
Patch "Fix Super Sonic Mouth Switching" in "Fixes/Graphics" by "ĐeäTh & Sajid" does
/*
Fixes the double mouth showing up on Super Sonic's Model instead of the mouth swapping working in real time.
*/
// The following is copied assembly from a compiled C++ DLL code.
// The full C++ source code for the code for this code can be found on:
// https://github.com/DeaTh-G/slw-super-sonic-fix 

{
MemoryProvider.SetAssemblerSymbol("aChrSupersonic", (uint)System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi("chr_supersonic").ToInt32());
MemoryProvider.SetAssemblerSymbol("aSonicMouthL", (uint)System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi("Sonic_Mouth_L").ToInt32());
MemoryProvider.SetAssemblerSymbol("buffer", (uint)System.Runtime.InteropServices.Marshal.AllocHGlobal(2097152).ToInt32());
MemoryProvider.SetAssemblerSymbol("pos", (uint)System.Runtime.InteropServices.Marshal.AllocHGlobal(4).ToInt32());
MemoryProvider.SetAssemblerSymbol("returnAddress", (uint)ASLR(0x00BFDC16));

WriteAsmHook
(
    $@"
        push ebp
        mov ebp, esp
        sub esp, 0x18
        push ebx
        push esi
        push edi
        mov edi, ecx
        mov dword ptr ss:[ebp-0x18], edx
        mov ecx, dword ptr ss:[ebp+8]
        mov esi, aChrSupersonic
        mov dword ptr ss:[ebp-0xC], edi
        mov eax, ecx
        cmp byte ptr ds:[ecx], 0
        je loc_10003A87

    loc_10003A70:
        mov cl, byte ptr ds:[esi]
        test cl, cl
        je loc_10003A87
        mov dl, byte ptr ds:[eax]
        cmp dl, cl
        jne loc_10003B70
        inc eax
        inc esi
        cmp byte ptr ds:[eax], 0
        jne loc_10003A70

    loc_10003A87:
        cmp byte ptr ds:[eax], 0
        jne loc_10003F6D
        cmp byte ptr ds:[esi], 0

    loc_10003A93:
        jne loc_10003F6D
        mov ebx, dword ptr ds:[edi]
        mov ecx, dword ptr ds:[ebx]
        bswap ecx
        test ecx, ecx
        jns loc_10003F6D
        and ecx, 0x7FFFFFFF
        mov dword ptr ss:[ebp-4], 0
        mov dword ptr ss:[ebp-0x10], ecx
        mov edx, 0
        jbe loc_10003B25
        cmp ecx, 8
        jb loc_10003B25
        mov eax, ecx
        xorps xmm1, xmm1
        and eax, 0xFFFFFFF8
        xorps xmm2, xmm2
        xchg ax, ax

    loc_10003AD0:
        movd xmm0, dword ptr ds:[ebx+edx]
        punpcklbw xmm0, xmm0
        punpcklwd xmm0, xmm0
        psrad xmm0, 0x18
        paddd xmm1, xmm0
        movd xmm0, dword ptr ds:[ebx+edx+4]
        punpcklbw xmm0, xmm0
        add edx, 8
        punpcklwd xmm0, xmm0
        psrad xmm0, 0x18
        paddd xmm2, xmm0
        cmp edx, eax
        jb loc_10003AD0
        paddd xmm1, xmm2
        movaps xmm0, xmm1
        psrldq xmm0, 8
        paddd xmm1, xmm0
        movups xmm0, xmm1
        psrldq xmm0, 4
        paddd xmm1, xmm0
        movd dword ptr ss:[ebp-4], xmm1

    loc_10003B25:
        xor esi, esi
        xor edi, edi
        cmp edx, ecx
        jae loc_10003B87
        mov eax, ecx
        sub eax, edx
        cmp eax, 2
        jb loc_10003B60
        lea eax, dword ptr ds:[ecx-1]
        mov ecx, eax
        nop dword ptr ds:[eax+eax], eax

    loc_10003B40:
        movsx eax, byte ptr ds:[ebx+edx]
        add esi, eax
        movsx eax, byte ptr ds:[ebx+edx+1]
        add edx, 2
        add edi, eax
        cmp edx, ecx
        jb loc_10003B40
        mov ecx, dword ptr ss:[ebp-0x10]
        cmp edx, ecx
        jae loc_10003B7D
        nop dword ptr ds:[eax+eax], eax

    loc_10003B60:
        movsx eax, byte ptr ds:[ebx+edx]
        mov edx, dword ptr ss:[ebp-4]
        add edx, eax
        lea eax, dword ptr ds:[edi+esi]
        add edx, eax
        jmp loc_10003B8A

    loc_10003B70:
        movsx eax, cl
        movsx ecx, dl
        sub ecx, eax
        jmp loc_10003A93

    loc_10003B7D:
        mov edx, dword ptr ss:[ebp-4]
        lea eax, dword ptr ds:[edi+esi]
        add edx, eax
        jmp loc_10003B8A

    loc_10003B87:
        mov edx, dword ptr ss:[ebp-4]

    loc_10003B8A:
        cmp edx, 0x3E7A1D
        jne loc_10003F6A
        mov esi, dword ptr ss:[ebp-0xC]
        mov ebx, buffer
        mov dword ptr ds:[pos], ecx
        mov esi, dword ptr ds:[esi]
        cmp ebx, esi
        jae loc_10003BC3
        test ecx, ecx
        je loc_10003BDE
        mov edx, ebx
        sub esi, ebx

    loc_10003BB3:
        mov al, byte ptr ds:[esi+edx]
        lea edx, dword ptr ds:[edx+1]
        mov byte ptr ds:[edx-1], al
        sub ecx, 1
        jne loc_10003BB3
        jmp loc_10003BDE

    loc_10003BC3:
        jbe loc_10003BDE
        test ecx, ecx
        je loc_10003BDE
        lea edx, dword ptr ds:[ebx-1]
        add edx, ecx
        sub esi, ebx

    loc_10003BD0:
        mov al, byte ptr ds:[edx+esi]
        lea edx, dword ptr ds:[edx-1]
        mov byte ptr ds:[edx+1], al
        sub ecx, 1
        jne loc_10003BD0

    loc_10003BDE:
        mov esi, dword ptr ds:[ebx+8]
        lea edi, dword ptr ds:[ebx+0x10]
        mov eax, dword ptr ds:[ebx+0xC]
        xor edx, edx
        bswap esi
        bswap eax
        add esi, ebx
        test eax, eax
        je loc_10003C0C

    loc_10003BF3:
        mov ecx, dword ptr ds:[esi+edx*4]
        inc edx
        bswap ecx
        mov eax, dword ptr ds:[ecx+edi]
        bswap eax
        add eax, edi
        mov dword ptr ds:[ecx+edi], eax
        mov eax, dword ptr ds:[ebx+0xC]
        bswap eax
        cmp edx, eax
        jb loc_10003BF3

    loc_10003C0C:
        add dword ptr ds:[ebx+0x30], 0x1000000
        mov eax, dword ptr ds:[pos]
        mov edx, dword ptr ds:[ebx+0x30]
        bswap edx
        lea ecx, dword ptr ds:[eax+3]
        and ecx, 0xFFFFFFFC
        lea eax, dword ptr ds:[eax+edx*4]
        mov dword ptr ds:[pos], eax
        mov eax, dword ptr ds:[ebx+0x30]
        lea edx, dword ptr ds:[ecx+ebx]
        xor ecx, ecx
        bswap eax
        sub eax, 1
        je loc_10003C54
        nop word ptr ds:[eax+eax], ax

    loc_10003C40:
        mov eax, dword ptr ds:[ebx+0x34]
        mov eax, dword ptr ds:[eax+ecx*4]
        mov dword ptr ds:[edx+ecx*4], eax
        inc ecx
        mov eax, dword ptr ds:[ebx+0x30]
        bswap eax
        dec eax
        cmp ecx, eax
        jb loc_10003C40

    loc_10003C54:
        mov dword ptr ds:[ebx+0x34], edx
        mov edx, dword ptr ds:[pos]
        lea ecx, dword ptr ds:[edx+0xB]
        and ecx, 0xFFFFFFFC
        lea edi, dword ptr ds:[edx+3]
        and edi, 0xFFFFFFFC
        lea eax, dword ptr ds:[edx+0x3D]
        add edi, ebx
        mov dword ptr ds:[pos], eax
        lea edx, dword ptr ds:[ecx+ebx]
        test edx, edx
        je loc_10003CB8
        lea eax, dword ptr ds:[edx+0x28]
        mov dword ptr ds:[edx], 0x2000000
        mov esi, aSonicMouthL
        mov dword ptr ds:[edx+4], edi
        mov dword ptr ds:[edx+8], 0
        mov cl, 0x53
        mov dword ptr ds:[edx+0x10], 0
        sub esi, eax
        mov dword ptr ds:[edx+0x18], 0

    loc_10003CA4:
        mov byte ptr ds:[eax], cl
        lea eax, dword ptr ds:[eax+1]
        mov cl, byte ptr ds:[eax+esi]
        test cl, cl
        jne loc_10003CA4
        mov byte ptr ds:[eax], cl
        mov eax, dword ptr ds:[ebx+0x34]
        mov dword ptr ds:[eax+8], edx

    loc_10003CB8:
        test edi, edi
        je loc_10003D39
        mov eax, dword ptr ds:[ebx+0x34]
        mov eax, dword ptr ds:[eax]
        mov eax, dword ptr ds:[eax+4]
        mov eax, dword ptr ds:[eax+0xC]
        mov dword ptr ds:[edi], eax
        mov eax, dword ptr ds:[ebx+0x34]
        mov eax, dword ptr ds:[eax]
        mov eax, dword ptr ds:[eax+4]
        lea ecx, dword ptr ds:[eax+0xC]
        lea edx, dword ptr ds:[eax+0x10]
        cmp ecx, edx
        jae loc_10003D12
        lea eax, dword ptr ds:[edx+0x1F]
        lea esi, dword ptr ds:[ecx+0x1F]
        cmp ecx, eax
        ja loc_10003D02
        cmp esi, edx
        jb loc_10003D02
        mov edx, 0x20

    loc_10003CF2:
        mov al, byte ptr ds:[ecx+4]
        lea ecx, dword ptr ds:[ecx+1]
        mov byte ptr ds:[ecx-1], al
        sub edx, 1
        jne loc_10003CF2
        jmp loc_10003D2E

    loc_10003D02:
        movups xmm0, xmmword ptr ds:[edx]
        movups xmmword ptr ds:[ecx], xmm0
        movups xmm0, xmmword ptr ds:[edx+0x10]
        movups xmmword ptr ds:[ecx+0x10], xmm0
        jmp loc_10003D2E

    loc_10003D12:
        jbe loc_10003D2E
        add ecx, 0x1F
        mov edx, 0x20
        nop dword ptr ds:[eax], eax

    loc_10003D20:
        mov al, byte ptr ds:[ecx+4]
        lea ecx, dword ptr ds:[ecx-1]
        mov byte ptr ds:[ecx+1], al
        sub edx, 1
        jne loc_10003D20

    loc_10003D2E:
        mov eax, dword ptr ds:[ebx+0x34]
        mov eax, dword ptr ds:[eax]
        add dword ptr ds:[eax], 0xFF000000

    loc_10003D39:
        mov esi, dword ptr ds:[pos]
        add dword ptr ds:[pos], 0x2C
        add esi, 3
        and esi, 0xFFFFFFFC
        add esi, ebx
        mov dword ptr ss:[ebp-0x10], esi
        je loc_10003D9C
        mov eax, dword ptr ds:[ebx+0x34]
        mov eax, dword ptr ds:[eax]
        mov eax, dword ptr ds:[eax+4]
        mov eax, dword ptr ds:[eax]
        mov eax, dword ptr ds:[eax]
        mov dword ptr ds:[esi], eax
        mov eax, dword ptr ds:[ebx+0x34]
        mov eax, dword ptr ds:[eax]
        mov eax, dword ptr ds:[eax+4]
        mov eax, dword ptr ds:[eax]
        mov eax, dword ptr ds:[eax+0x18]
        mov dword ptr ds:[esi+0x18], eax
        mov eax, dword ptr ds:[ebx+0x34]
        mov eax, dword ptr ds:[eax]
        mov eax, dword ptr ds:[eax+4]
        mov eax, dword ptr ds:[eax]
        mov ecx, dword ptr ds:[eax+0x24]
        mov eax, dword ptr ds:[eax+0x28]
        mov dword ptr ds:[esi+0x24], ecx
        mov dword ptr ds:[esi+0x28], eax
        mov dword ptr ds:[esi+0xC], 0x4C000000
        mov dword ptr ds:[esi+0x10], 0x68000000
        test edi, edi
        je loc_10003D9C
        mov dword ptr ds:[edi+4], esi

    loc_10003D9C:
        mov eax, dword ptr ds:[pos]
        lea edx, dword ptr ds:[eax+0x118]
        lea edi, dword ptr ds:[eax+ebx]
        mov dword ptr ds:[pos], edx
        mov ecx, dword ptr ds:[esi+0x10]
        add eax, 3
        and eax, 0xFFFFFFFE
        add eax, ebx
        mov dword ptr ss:[ebp-8], eax
        mov eax, dword ptr ds:[esi+0xC]
        bswap ecx
        bswap eax
        imul ecx, eax
        add ecx, edx
        mov dword ptr ds:[pos], ecx
        lea ecx, dword ptr ds:[edx+ebx]
        mov dword ptr ss:[ebp-4], ecx
        test edi, edi
        je loc_10003DE9
        mov word ptr ds:[edi], 0x332F
        mov dword ptr ds:[esi+0x1C], 0x2000000
        mov dword ptr ds:[esi+0x20], edi

    loc_10003DE9:
        cmp dword ptr ss:[ebp-8], 0
        je loc_10003E81
        mov eax, dword ptr ds:[ebx+0x34]
        xor edi, edi
        xor edx, edx
        mov eax, dword ptr ds:[eax]
        mov eax, dword ptr ds:[eax+4]
        mov esi, dword ptr ds:[eax]
        mov eax, dword ptr ds:[esi+4]
        bswap eax
        test eax, eax
        je loc_10003E73
        mov ebx, dword ptr ss:[ebp-8]
        nop dword ptr ds:[eax], eax

    loc_10003E10:
        mov eax, dword ptr ds:[esi+8]
        movzx ecx, word ptr ds:[eax+edx*2]
        mov eax, 0xFFFF
        cmp cx, ax
        je loc_10003E60
        mov ah, cl
        mov al, ch
        mov ecx, dword ptr ds:[esi+0x10]
        mov dword ptr ss:[ebp-0x14], eax
        movzx eax, ax
        bswap ecx
        imul ecx, eax
        mov eax, dword ptr ds:[esi+0x14]
        mov al, byte ptr ds:[ecx+eax+0x60]
        cmp al, 9
        je loc_10003E42
        cmp al, 0xA
        jne loc_10003E60

    loc_10003E42:
        mov ecx, dword ptr ss:[ebp-0x14]
        add ecx, 0xFFFFFF02
        mov ah, cl
        mov al, ch
        mov ecx, 0xFFFF
        mov word ptr ds:[ebx+edi*2], ax
        inc edi
        mov eax, dword ptr ds:[esi+8]
        mov word ptr ds:[eax+edx*2], cx

    loc_10003E60:
        mov eax, dword ptr ds:[esi+4]
        inc edx
        bswap eax
        cmp edx, eax
        jb loc_10003E10
        mov ebx, buffer
        mov ecx, dword ptr ss:[ebp-4]

    loc_10003E73:
        mov esi, dword ptr ss:[ebp-0x10]
        mov eax, dword ptr ss:[ebp-8]
        bswap edi
        mov dword ptr ds:[esi+4], edi
        mov dword ptr ds:[esi+8], eax

    loc_10003E81:
        test ecx, ecx
        je loc_10003F5A
        mov eax, dword ptr ds:[ebx+0x34]
        xor edi, edi
        mov dword ptr ss:[ebp-8], edi
        mov eax, dword ptr ds:[eax]
        mov eax, dword ptr ds:[eax+4]
        mov eax, dword ptr ds:[eax]
        mov dword ptr ss:[ebp-0x14], eax
        mov ecx, dword ptr ds:[eax+0xC]
        mov edx, dword ptr ds:[eax+0x10]
        mov eax, edx
        bswap ecx
        bswap eax
        imul ecx, eax
        test ecx, ecx
        je loc_10003F54
        xor ebx, ebx

    loc_10003EB4:
        mov eax, dword ptr ss:[ebp-0x14]
        add edi, dword ptr ds:[eax+0x14]
        mov al, byte ptr ds:[edi+0x60]
        cmp al, 9
        je loc_10003EC5
        cmp al, 0xA
        jne loc_10003F22

    loc_10003EC5:
        mov ecx, dword ptr ds:[esi+0x10]
        bswap ecx
        imul ecx, ebx
        bswap edx
        add ecx, dword ptr ss:[ebp-4]
        cmp ecx, edi
        jae loc_10003EF0
        test edx, edx
        je loc_10003F11
        sub edi, ecx
        nop dword ptr ds:[eax], eax

    loc_10003EE0:
        mov al, byte ptr ds:[edi+ecx]
        lea ecx, dword ptr ds:[ecx+1]
        mov byte ptr ds:[ecx-1], al
        sub edx, 1
        jne loc_10003EE0
        jmp loc_10003F11

    loc_10003EF0:
        jbe loc_10003F11
        test edx, edx
        je loc_10003F11
        lea esi, dword ptr ds:[ecx-1]
        add esi, edx
        sub edi, ecx
        nop dword ptr ds:[eax], eax

    loc_10003F00:
        mov al, byte ptr ds:[esi+edi]
        lea esi, dword ptr ds:[esi-1]
        mov byte ptr ds:[esi+1], al
        sub edx, 1
        jne loc_10003F00
        mov esi, dword ptr ss:[ebp-0x10]

    loc_10003F11:
        mov eax, dword ptr ds:[esi+0x10]
        mov ecx, dword ptr ss:[ebp-4]
        bswap eax
        imul eax, ebx
        add byte ptr ds:[eax+ecx+0x60], 0xF7
        inc ebx

    loc_10003F22:
        mov eax, dword ptr ds:[esi+0xC]
        bswap eax
        cmp ebx, eax
        je loc_10003F4E
        mov eax, dword ptr ss:[ebp-0x14]
        mov edi, dword ptr ss:[ebp-8]
        add edi, 0x68
        mov dword ptr ss:[ebp-8], edi
        mov edx, dword ptr ds:[eax+0x10]
        mov ecx, edx
        mov eax, dword ptr ds:[eax+0xC]
        bswap ecx
        bswap eax
        imul ecx, eax
        cmp edi, ecx
        jb loc_10003EB4

    loc_10003F4E:
        mov ebx, buffer

    loc_10003F54:
        mov eax, dword ptr ss:[ebp-4]
        mov dword ptr ds:[esi+0x14], eax

    loc_10003F5A:
        mov eax, dword ptr ss:[ebp-0xC]
        mov ecx, eax
        mov dword ptr ds:[ebx+0xC], 0
        mov dword ptr ds:[eax], ebx
        jmp loc_10003F6F

    loc_10003F6A:
        mov edi, dword ptr ss:[ebp-0xC]

    loc_10003F6D:    
        mov ecx, edi

    loc_10003F6F:
        push dword ptr ss:[ebp+0x10]
        mov edx, dword ptr ss:[ebp-0x18]
        push dword ptr ss:[ebp+0xC]
        push dword ptr ss:[ebp+8]
        call originalReplace
        pop edi
        pop esi
        pop ebx
        mov esp, ebp
        pop ebp
        ret 0xC
        endp
        
    originalReplace:
        push ebp
        mov ebp, esp
        sub esp, 0x3C
        mov eax, returnAddress
        jmp eax
    ",
    ASLR(0x00BFDC10), HookBehavior.Replace
)
}
Code "Adjust Aspect Ratio to Resolution" in "Graphics/Display" by "Muzzarino" does "Dynamically adjusts the aspect ratio to match the game resolution (recommended for ultrawide)." 
var ptr = GetPointer(ASLR(0x00FD3CA8))
WriteProtected<float>(ASLR(0x00D56D30), ptr != 0 ? (float)(Read<uint>(ptr + 0xF8)) / (float)(Read<uint>(ptr + 0xFC)) : 16f / 9f)
WriteProtected<double>(ASLR(0x00EB2E00), (Double)Read<float>(ASLR(0x00D56D30)))
WriteProtected<float>(ASLR(0x00FB6AF0), 2f * (float)Math.Atan((float)Math.Tan(60f * 0.00872664625997164788461845384244) / (Read<float>(ASLR(0x00D56D30)) < 16f / 9f ? Read<float>(ASLR(0x00D56D30)) : 16f / 9f) * (16f / 9f)))
WriteProtected<float>(ASLR(0x00D6F364), 720f / (Read<float>(ASLR(0x00D56D30)) < 16f / 9f ? Read<float>(ASLR(0x00D56D30)) : 16f / 9f) * (16f / 9f)))
WriteProtected<float>(ASLR(0x00D6F360), Read<float>(ASLR(0x00D6F364)) * Read<float>(ASLR(0x00D56D30)))

string code = $@"mulss xmm0,[{ASLR(0x00E737E4)}]
cvtps2pd xmm0,xmm0
pushad
mov eax,{ASLR(0x00C76D12)}
call eax
mov eax,{ASLR(0x00C64010)}
call eax
cvtsi2sd xmm2,eax
cvtsi2sd xmm1,edx
popad
divsd xmm2,xmm1
movss xmm1,[esp+0x4]
cvtps2pd xmm1,xmm1
minsd xmm1,xmm2
divsd xmm1,xmm2
divsd xmm0,xmm1
sub esp,0x8
movsd [esp],xmm0
fld qword ptr [esp]
add esp,0x8
fld1
fpatan
fdiv dword ptr [{ASLR(0x00E737E4)}]
fstp dword ptr [esp]
mov eax,{ASLR(0x008FF5B0)}
call eax"

string code2 = $@"mulss xmm0,[{ASLR(0x00E737E4)}]
cvtps2pd xmm0,xmm0
pushad
mov eax,{ASLR(0x00C76D12)}
call eax
mov eax,{ASLR(0x00C64010)}
call eax
cvtsi2sd xmm2,eax
cvtsi2sd xmm1,edx
popad
divsd xmm2,xmm1
movss xmm1,[esp+0x8]
cvtps2pd xmm1,xmm1
minsd xmm1,xmm2
divsd xmm1,xmm2
divsd xmm0,xmm1
sub esp,0x8
movsd [esp],xmm0
fld qword ptr [esp]
add esp,0x8
fld1
fpatan
fdiv dword ptr [{ASLR(0x00E737E4)}]
fstp dword ptr [esp+0x4]
mov eax,{ASLR(0x00967820)}
call eax"

string code3 = $@"mov eax,[{ASLR(0x00FD3CA8)}]
test eax,eax
je NoVPaddress
mov edx,[eax+0xFC]
mov eax,[eax+0xF8]
NoVPaddress:"

string code4 = $@"cvtdq2ps xmm0,xmm0
cvtdq2ps xmm1,xmm1
sub esp,0x8
movss [esp],xmm0
movss [esp+0x4],xmm1
mov eax,[{ASLR(0x00FD3CA8)}]
movd xmm0,[eax+0xF8]
movd xmm1,[eax+0xFC]
mov eax,{ASLR(0x00C64010)}
call eax
sar eax,1
sar edx,1
cvtdq2ps xmm0,xmm0
cvtdq2ps xmm1,xmm1
divss xmm0,xmm1
movss xmm4,xmm0
movss xmm1,[esp]
divss xmm1,[esp+0x4]
minss xmm0,xmm1
divss xmm0,xmm1
divss xmm1,xmm4
mulss xmm1,xmm0
cvtsi2ss xmm4,eax
movss xmm5,xmm4
divss xmm4,xmm1
subss xmm4,xmm5
addss xmm2,xmm4
cvtsi2ss xmm4,edx
movss xmm5,xmm4
divss xmm4,xmm0
subss xmm4,xmm5
addss xmm3,xmm4
movss xmm4,xmm0
movss xmm5,xmm1
movss xmm0,[esp]
movss xmm1,[esp+0x4]
mulss xmm0,xmm5
mulss xmm1,xmm4
add esp,0x8
cvtps2dq xmm0,xmm0
cvtps2dq xmm1,xmm1"

string code5 = $@"mov eax,{ASLR(0x00C64010)}
call eax
cvtsi2ss xmm3,eax
cvtsi2ss xmm2,edx
divss xmm3,xmm2"

string code6 = $@"mov eax,{ASLR(0x00C76F67)}
call eax
movss xmm1,xmm0
divss xmm0,[{ASLR(0x00D56D30)}]
divss xmm0,[{ASLR(0x00D56D2C)}]
maxss xmm0,xmm1"

string code7 = $@"movss xmm0,xmm5
divss xmm0,[edi+0x1B4]
minss xmm0,[{ASLR(0x00D56D30)}]
divss xmm0,[{ASLR(0x00D56D30)}]
mulss xmm5,xmm0"

string code8 = $@"movss xmm4,[edi+0x1B0]
divss xmm4,[edi+0x1B4]
maxss xmm4,[{ASLR(0x00D56D30)}]
divss xmm4,[{ASLR(0x00D56D30)}]
divss xmm7,xmm4"

string code9 = $@"movss xmm6,[{ASLR(0x00D56D30)}]
divss xmm0,[{ASLR(0x00D56D2C)}]
minss xmm6,xmm0
divss xmm6,xmm0
movss xmm0,xmm6"

string code10 = $@"movss xmm5,[{ASLR(0x00E72E24)}]
divss xmm5,[{ASLR(0x00D56D2C)}]
minss xmm5,[{ASLR(0x00D56D30)}]
divss xmm2,xmm5
mulss xmm2,[{ASLR(0x00D56D30)}]"

string code11 = $@"movss xmm5,[{ASLR(0x00E72E24)}]
divss xmm5,[{ASLR(0x00D56D2C)}]
maxss xmm5,[{ASLR(0x00D56D30)}]
mulss xmm1,xmm5
divss xmm1,[{ASLR(0x00D56D30)}]"

if (Read<byte>(ASLR(0x004178AB)) == 0xE8)
{
    WriteAsmHook(code, ASLR(0x004178AB), HookBehavior.Replace)
    WriteAsmHook(code, ASLR(0x00419601), HookBehavior.Replace)
    WriteAsmHook(code2, ASLR(0x0041E9D0), HookBehavior.Replace)
    WriteAsmHook(code2, ASLR(0x0042589C), HookBehavior.Replace)
    WriteAsmHook(code2, ASLR(0x004272F5), HookBehavior.Replace)
    WriteAsmHook(code2, ASLR(0x00427DF0), HookBehavior.Replace)
    WriteAsmHook(code2, ASLR(0x00428878), HookBehavior.Replace)
    WriteAsmHook(code2, ASLR(0x004292FE), HookBehavior.Replace)
    WriteAsmHook(code2, ASLR(0x00437490), HookBehavior.Replace)
    WriteAsmHook(code2, ASLR(0x0043CB11), HookBehavior.Replace)
    WriteAsmHook(code2, ASLR(0x00530664), HookBehavior.Replace)
    WriteAsmHook(code3, ASLR(0x005305F9), HookBehavior.Replace)
    WriteAsmHook(code4, ASLR(0x004A824C), HookBehavior.Before)
    WriteAsmHook(code5, ASLR(0x00401737), HookBehavior.Replace)
    WriteAsmHook(code6, ASLR(0x0043D41E), HookBehavior.Replace)
    WriteAsmHook(code6, ASLR(0x00441D41), HookBehavior.Replace)
    WriteAsmHook(code7, ASLR(0x0049C380), HookBehavior.Before)
    WriteAsmHook(code8, ASLR(0x0049C3BA), HookBehavior.Before)
    WriteAsmHook(code9, ASLR(0x0041EA22), HookBehavior.Before)
    WriteAsmHook(code10, ASLR(0x008FF420), HookBehavior.Before)
    WriteAsmHook(code11, ASLR(0x008FF456), HookBehavior.Before)
}



Patch "Force Language to English" in "System/Language" by "M&M & ĐeäTh" 
WriteAsmHook(ASLR(0x004AB9FF), HookBehavior.Replace, "mov eax, 1");



Patch "Force Language to French" in "System/Language" by "M&M & ĐeäTh" 
WriteAsmHook(ASLR(0x004AB9FF), HookBehavior.Replace, "mov eax, 2");



Patch "Force Language to German" in "System/Language" by "M&M & ĐeäTh" 
WriteAsmHook(ASLR(0x004AB9FF), HookBehavior.Replace, "mov eax, 3");



Patch "Force Language to Italian" in "System/Language" by "M&M & ĐeäTh" 
WriteAsmHook(ASLR(0x004AB9FF), HookBehavior.Replace, "mov eax, 4");



Patch "Force Language to Japanese" in "System/Language" by "M&M & ĐeäTh" 
WriteAsmHook(ASLR(0x004AB9FF), HookBehavior.Replace, "mov eax, 0");



Patch "Force Language to Spanish" in "System/Language" by "M&M & ĐeäTh" 
WriteAsmHook(ASLR(0x004AB9FF), HookBehavior.Replace, "mov eax, 5");



Patch "16:10" in "Graphics/Display/Internal Resolution" by "ĐeäTh" does "Changes the game in-game resolution to a 16:10 aspect ratio. Perfect for the Steam Deck." 
WriteProtected<int>(ASLR(0x00D56D30), 0x3FCCCCCD)



Patch "21:9 (2560x1080)" in "Graphics/Display/Internal Resolution" by "ĐeäTh" does "Changes the game in-game resolution to a 21:9 (2560x1080) aspect ratio." 
WriteProtected<int>(ASLR(0x00D56D30), 0x4017B426)



Patch "21:9 (3440x1440)" in "Graphics/Display/Internal Resolution" by "ĐeäTh" does "Changes the game in-game resolution to a 21:9 (3440x1440) aspect ratio." 
WriteProtected<int>(ASLR(0x00D56D30), 0x4018E38E)



Patch "21:9 (3840x1600)" in "Graphics/Display/Internal Resolution" by "ĐeäTh" does "Changes the game in-game resolution to a 21:9 (3840x1600) aspect ratio." 
WriteProtected<int>(ASLR(0x00D56D30), 0x4019999A)



Patch "32:9" in "Graphics/Display/Internal Resolution" by "ĐeäTh" does "Changes the game in-game resolution to a 32:9 aspect ratio." 
WriteProtected<int>(ASLR(0x00D56D30), 0x40638E39)



Patch "1280x720" in "Graphics/Display/Internal Resolution/Movie Player" by "ĐeäTh" does "Forces the CRIWARE video player to use a 1280x720 viewport. This is only useful for mods that have higher resolution video files." 
static float ms_RenderTextureMultiplier = 1.0f;
fixed(float* multiplierPtr = &ms_RenderTextureMultiplier)
{
    WriteAsmHook
    (
        ASLR(0x0049C398),
        HookBehavior.Replace,
        $"mulss xmm5, [{(uint)multiplierPtr}]"
    )

    WriteAsmHook
    (
        ASLR(0x0049C3C2),
        HookBehavior.Replace,
        $"mulss xmm7, [{(uint)multiplierPtr}]"
    )
}

WriteProtected<float>(ASLR(0x00D61CE8), 1280);
WriteProtected<float>(ASLR(0x00D593B0), 720);



Patch "1920x1080" in "Graphics/Display/Internal Resolution/Movie Player" by "ĐeäTh" does "Forces the CRIWARE video player to use a 1920x1080 viewport. This is only useful for mods that have higher resolution video files." 
static float ms_RenderTextureMultiplier = 1.0f;
fixed(float* multiplierPtr = &ms_RenderTextureMultiplier)
{
    WriteAsmHook
    (
        ASLR(0x0049C398),
        HookBehavior.Replace,
        $"mulss xmm5, [{(uint)multiplierPtr}]"
    )

    WriteAsmHook
    (
        ASLR(0x0049C3C2),
        HookBehavior.Replace,
        $"mulss xmm7, [{(uint)multiplierPtr}]"
    )
}

WriteProtected<float>(ASLR(0x00D61CE8), 1920);
WriteProtected<float>(ASLR(0x00D593B0), 1080);



Patch "2560x1080" in "Graphics/Display/Internal Resolution/Movie Player" by "ĐeäTh" does "Forces the CRIWARE video player to use a 2560x1080 viewport. This is only useful for mods that have higher resolution video files." 
static float ms_RenderTextureMultiplier = 1.0f;
fixed(float* multiplierPtr = &ms_RenderTextureMultiplier)
{
    WriteAsmHook
    (
        ASLR(0x0049C398),
        HookBehavior.Replace,
        $"mulss xmm5, [{(uint)multiplierPtr}]"
    )

    WriteAsmHook
    (
        ASLR(0x0049C3C2),
        HookBehavior.Replace,
        $"mulss xmm7, [{(uint)multiplierPtr}]"
    )
}

WriteProtected<float>(ASLR(0x00D61CE8), 2560);
WriteProtected<float>(ASLR(0x00D593B0), 1080);



Patch "2560x1440" in "Graphics/Display/Internal Resolution/Movie Player" by "ĐeäTh" does "Forces the CRIWARE video player to use a 2560x1440 viewport. This is only useful for mods that have higher resolution video files." 
static float ms_RenderTextureMultiplier = 1.0f;
fixed(float* multiplierPtr = &ms_RenderTextureMultiplier)
{
    WriteAsmHook
    (
        ASLR(0x0049C398),
        HookBehavior.Replace,
        $"mulss xmm5, [{(uint)multiplierPtr}]"
    )

    WriteAsmHook
    (
        ASLR(0x0049C3C2),
        HookBehavior.Replace,
        $"mulss xmm7, [{(uint)multiplierPtr}]"
    )
}

WriteProtected<float>(ASLR(0x00D61CE8), 2560);
WriteProtected<float>(ASLR(0x00D593B0), 1440);



Patch "3440x1440" in "Graphics/Display/Internal Resolution/Movie Player" by "ĐeäTh" does "Forces the CRIWARE video player to use a 3440x1440 viewport. This is only useful for mods that have higher resolution video files." 
static float ms_RenderTextureMultiplier = 1.0f;
fixed(float* multiplierPtr = &ms_RenderTextureMultiplier)
{
    WriteAsmHook
    (
        ASLR(0x0049C398),
        HookBehavior.Replace,
        $"mulss xmm5, [{(uint)multiplierPtr}]"
    )

    WriteAsmHook
    (
        ASLR(0x0049C3C2),
        HookBehavior.Replace,
        $"mulss xmm7, [{(uint)multiplierPtr}]"
    )
}

WriteProtected<float>(ASLR(0x00D61CE8), 3440);
WriteProtected<float>(ASLR(0x00D593B0), 1440);



Patch "3840x2160" in "Graphics/Display/Internal Resolution/Movie Player" by "ĐeäTh" does "Forces the CRIWARE video player to use a 3840x2160 viewport. This is only useful for mods that have higher resolution video files." 
static float ms_RenderTextureMultiplier = 1.0f;
fixed(float* multiplierPtr = &ms_RenderTextureMultiplier)
{
    WriteAsmHook
    (
        ASLR(0x0049C398),
        HookBehavior.Replace,
        $"mulss xmm5, [{(uint)multiplierPtr}]"
    )

    WriteAsmHook
    (
        ASLR(0x0049C3C2),
        HookBehavior.Replace,
        $"mulss xmm7, [{(uint)multiplierPtr}]"
    )
}

WriteProtected<float>(ASLR(0x00D61CE8), 3840);
WriteProtected<float>(ASLR(0x00D593B0), 2160);



Patch "5120x2160" in "Graphics/Display/Internal Resolution/Movie Player" by "ĐeäTh" does "Forces the CRIWARE video player to use a 5120x2160 viewport. This is only useful for mods that have higher resolution video files." 
static float ms_RenderTextureMultiplier = 1.0f;
fixed(float* multiplierPtr = &ms_RenderTextureMultiplier)
{
    WriteAsmHook
    (
        ASLR(0x0049C398),
        HookBehavior.Replace,
        $"mulss xmm5, [{(uint)multiplierPtr}]"
    )

    WriteAsmHook
    (
        ASLR(0x0049C3C2),
        HookBehavior.Replace,
        $"mulss xmm7, [{(uint)multiplierPtr}]"
    )
}

WriteProtected<float>(ASLR(0x00D61CE8), 5120);
WriteProtected<float>(ASLR(0x00D593B0), 2160);



