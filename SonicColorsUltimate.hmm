Library "Bitwise" by "Hyper" 
{
    public long Set(long in_base, int in_offset, bool in_isOffsetBitIndex = true)
    {
        return in_base | (in_isOffsetBitIndex ? (1L << in_offset) : in_offset);
    }

    public long Reset(long in_base, int in_offset, bool in_isOffsetBitIndex = true)
    {
        return in_base & (in_isOffsetBitIndex ? ~(1L << in_offset) : in_offset);
    }

    public bool Test(long in_base, int in_offset, bool in_isOffsetBitIndex = true)
    {
        return (in_base & (in_isOffsetBitIndex ? (1L << in_offset) : in_offset)) != 0;
    }
}
Library "HMM" by "Hyper"
{
    #lib "INI"

    using System.Collections.Generic;
    using System.IO;

    public Dictionary<string, Dictionary<string, string>> GetModsDatabase()
    {
        string workingDir = Directory.GetCurrentDirectory();
        string cpkredirCfgPath = Path.Combine(workingDir, "cpkredir.ini");

        if (!File.Exists(cpkredirCfgPath))
            return new();

        var cpkredirCfg = INI.Read(cpkredirCfgPath);
        string modsDbPath = cpkredirCfg["CPKREDIR"]["ModsDbIni"];

        if (!File.Exists(modsDbPath))
            return new();

        return INI.Read(modsDbPath);
    }

    public List<Mod> GetMods()
    {
        List<Mod> result = new();

        var modsDb = GetModsDatabase();

        if (modsDb == null)
            return result;

        int activeModCount = INI.Parse<int>(modsDb["Main"]["ActiveModCount"], 0);

        foreach (var entry in modsDb["Mods"].Keys)
        {
            for (int i = 0; i < activeModCount; i++)
            {
                if (modsDb["Main"][$"ActiveMod{i}"].Contains(entry))
                {
                    result.Add(new Mod(modsDb["Mods"][entry]));
                }
            }
        }

        return result;
    }

    public Mod GetModByID(string in_id)
    {
        foreach (var mod in GetMods())
        {
            if (mod.ID == in_id)
                return mod;
        }

        return null;
    }

    public List<Mod> FindModsByName(string name)
    {
        List<Mod> result = new();

        foreach (var mod in GetMods())
        {
            if (mod.Name.Contains(name))
            {
                result.Add(mod);
            }
        }

        return result;
    }

    public List<string> GetCodes()
    {
        List<string> result = new();

        var modsDb = GetModsDatabase();

        if (modsDb == null)
            return result;

        foreach (var value in modsDb["Codes"].Values)
            result.Add(value);

        return result;
    }

    public class Mod
    {
        public string Name { get; set; } = string.Empty;

        public string Version { get; set; } = string.Empty;

        public string Author { get; set; } = string.Empty;

        public string Description { get; set; } = string.Empty;

        public string Date { get; set; } = string.Empty;

        public string AuthorURL { get; set; } = string.Empty;

        public string UpdateServer { get; set; } = string.Empty;

        public string SaveFile { get; set; } = string.Empty;

        public string ID { get; set; } = string.Empty;

        public List<string> IncludeDirs { get; set; } = new();

        public List<ModDependency> Dependencies { get; set; } = new();

        public string DLLFile { get; set; } = string.Empty;

        public string CodeFile { get; set; } = string.Empty;

        public string ConfigSchemaFile { get; set; } = string.Empty;

        public string Path { get; set; } = string.Empty;

        public Dictionary<string, Dictionary<string, string>> Ini { get; set; } = new();

        public Mod(string modIniPath)
        {
            var ini = INI.Read(modIniPath);

            if (ini == null)
                return;

            Name             = INI.GetField<string>(ini, "Desc", "Title", Name);
            Version          = INI.GetField<string>(ini, "Desc", "Version", Version);
            Author           = INI.GetField<string>(ini, "Desc", "Author", Author);
            Description      = INI.GetField<string>(ini, "Desc", "Description", Description);
            Date             = INI.GetField<string>(ini, "Desc", "Date", Date);
            AuthorURL        = INI.GetField<string>(ini, "Desc", "AuthorURL", AuthorURL);
            UpdateServer     = INI.GetField<string>(ini, "Main", "UpdateServer", UpdateServer);
            SaveFile         = INI.GetField<string>(ini, "Main", "SaveFile", SaveFile);
            ID               = INI.GetField<string>(ini, "Main", "ID", ID);
            DLLFile          = INI.GetField<string>(ini, "Main", "DLLFile", DLLFile);
            CodeFile         = INI.GetField<string>(ini, "Main", "CodeFile", CodeFile);
            ConfigSchemaFile = INI.GetField<string>(ini, "Main", "ConfigSchemaFile", ConfigSchemaFile);

            Path             = System.IO.Path.GetDirectoryName(modIniPath);
            Ini              = ini;

            int includeDirCount = INI.GetField<int>(ini, "Main", "IncludeDirCount", 1);

            for (int i = 0; i < includeDirCount; i++)
                IncludeDirs.Add(INI.GetField<string>(ini, "Main", $"IncludeDir{i}", "."));

            int dependencyCount = INI.GetField<int>(ini, "Main", "DependsCount", 0);

            for (int i = 0; i < dependencyCount; i++)
                Dependencies.Add(new ModDependency(INI.GetField<string>(ini, "Main", $"Depends{i}", "")));
        }
    }

    public class ModDependency
    {
        public string ID { get; set; }

        public string Name { get; set; }
        
        public string Link { get; set; }

        public string Version { get; set; }

        public ModDependency(string in_id, string in_name, string in_link, string in_version)
        {
            ID = in_id;
            Name = in_name;
            Link = in_link;
            Version = in_version;
        }

        public ModDependency(string in_csv)
        {
            var fields = in_csv.Split('|');

            for (int i = 0; i < fields.Length; i++)
            {
                switch (i)
                {
                    case 0:
                        ID = fields[i];
                        break;

                    case 1:
                        Name = fields[i];
                        break;

                    case 2:
                    {
                        if (fields.Length > 2)
                        {
                            Link = fields[i];
                        }
                        else
                        {
                            Version = fields[i];
                        }

                        break;
                    }

                    case 3:
                        Version = fields[i];
                        break;
                }
            }
        }
    }
}
Library "INI" by "Hyper"
{
    using System.Collections.Generic;
    using System.IO;
    
    public Dictionary<string, Dictionary<string, string>> Read(string path)
    {
        Dictionary<string, Dictionary<string, string>> result = new();

        if (!File.Exists(path))
            return result;

        using (StreamReader reader = new StreamReader(path))
        {
            string section = string.Empty;
            string line = string.Empty;

            // Add root section.
            result.Add(section, new Dictionary<string, string>());

            while ((line = reader.ReadLine()) != null)
            {
                if (line.StartsWith("[") && line.EndsWith("]"))
                {
                    section = line.Substring(1, line.Length - 2);
                    result.Add(section, new Dictionary<string, string>());
                    continue;
                }

                if (line.StartsWith(";") || line.StartsWith("#"))
                    continue;

                int delimiterIndex = line.IndexOf('=');

                if (delimiterIndex == -1)
                    continue;

                string key = line.Substring(0, delimiterIndex);
                string value = line.Substring(delimiterIndex + 1);

                if (value.StartsWith("\"") && value.EndsWith("\"") && value.Length > 1)
                    value = value.Substring(1, value.Length - 2);
                
                result[section].Add(key, value);
            }
        }

        return result;
    }

    public T Parse<T>(string in_value, T in_defaultValue)
    {
        T result = in_defaultValue;

        if (typeof(T) == typeof(string))
        {
            result = (T)(object)in_value;
        }
        else if (typeof(T) == typeof(int))
        {
            if (int.TryParse(in_value, out int intValue))
            {
                result = (T)(object)intValue;
            }
        }
        else if (typeof(T) == typeof(double))
        {
            if (double.TryParse(in_value, out double doubleValue))
            {
                result = (T)(object)doubleValue;
            }
        }
        else if (typeof(T) == typeof(float))
        {
            if (float.TryParse(in_value, out float floatValue))
            {
                result = (T)(object)floatValue;
            }
        }

        return result;
    }

    public T GetField<T>(Dictionary<string, Dictionary<string, string>> in_ini, string in_section, string in_key, T in_defaultValue)
    {
        if (!in_ini.ContainsKey(in_section))
            return in_defaultValue;

        if (!in_ini[in_section].ContainsKey(in_key))
            return in_defaultValue;

        return Parse<T>(in_ini[in_section][in_key], in_defaultValue);
    }
}
Library "Logger" by "Hyper"
{
    #define PRINT_OBJECT(obj, format, caller) Logger.Utility(#obj + " = " + obj.ToString(format), caller);
    #define PRINT_OBJECT(obj, format) Logger.Utility(#obj + " = " + obj.ToString(format));

    public enum LogLevel
    {
        None,
        Utility,
        Warning,
        Error
    }

    public void Log(object message, LogLevel level = LogLevel.None, string caller = "")
    {
        var oldColour = Console.ForegroundColor;

        switch (level)
        {
            case LogLevel.Warning:
                Console.ForegroundColor = ConsoleColor.Yellow;
                break;

            case LogLevel.Error:
                Console.ForegroundColor = ConsoleColor.Red;
                break;

            case LogLevel.Utility:
                Console.ForegroundColor = ConsoleColor.Green;
                break;
        }

        Console.WriteLine(string.IsNullOrEmpty(caller) ? message.ToString() : $"[{caller}] {message}");

        Console.ForegroundColor = oldColour;
    }

    public void Utility(object message, string caller = "")
    {
        Log(message, LogLevel.Utility, caller);
    }

    public void Warning(object message, string caller = "")
    {
        Log(message, LogLevel.Warning, caller);
    }

    public void Error(object message, string caller = "")
    {
        Log(message, LogLevel.Error, caller);
    }
}
Library "MathHelpers" by "Hyper" 
{
    using System.Collections.Generic;

    public T Clamp<T>(T in_value, T in_minValue, T in_maxValue) where T : IComparable<T>
    {
        if (in_value.CompareTo(in_minValue) < 0)
        {
            return in_minValue;
        }
        else if (in_value.CompareTo(in_maxValue) > 0)
        {
            return in_maxValue;
        }
        else
        {
            return in_value;
        }
    }

    public T Clamp01<T>(T value) where T : IComparable<T>
    {
        if (value.CompareTo(default(T)) < 0)
        {
            return default(T);
        }
        else if (value.CompareTo((T)Convert.ChangeType(1, typeof(T))) > 0)
        {
            return (T)Convert.ChangeType(1, typeof(T));
        }
        else
        {
            return value;
        }
    }

    public T FloatPercentToRange<T>(float in_value)
    {
        if (typeof(T) == typeof(sbyte))
        {
            return (T)(object)(byte)(in_value * (sbyte.MaxValue * 1.0f));
        }
        else if (typeof(T) == typeof(byte))
        {
            return (T)(object)(byte)(in_value * (byte.MaxValue * 1.0f));
        }
        else if (typeof(T) == typeof(short))
        {
            return (T)(object)(short)(in_value * (short.MaxValue * 1.0f));
        }
        else if (typeof(T) == typeof(ushort))
        {
            return (T)(object)(ushort)(in_value * (ushort.MaxValue * 1.0f));
        }
        else if (typeof(T) == typeof(int))
        {
            return (T)(object)(int)(in_value * (int.MaxValue * 1.0f));
        }
        else if (typeof(T) == typeof(uint))
        {
            return (T)(object)(uint)(in_value * (uint.MaxValue * 1.0f));
        }
        else if (typeof(T) == typeof(long))
        {
            return (T)(object)(long)(in_value * (long.MaxValue * 1.0f));
        }
        else if (typeof(T) == typeof(ulong))
        {
            return (T)(object)(ulong)(in_value * (ulong.MaxValue * 1.0f));
        }
        
        return default;
    }
    
    public float Lerp(float in_start, float in_end, float in_time)
    {
        return in_start + (in_end - in_start) * in_time;
    }

    public static float InverseLerp(float a, float b, float value)
    {
        if (a == b)
            return 0.0f;

        return Clamp01<float>((value - a) / (b - a));
    }

    public static float ToDegrees(float in_radians)
    {
        return in_radians * (180.0f / (float)Math.PI);
    }

    public static float ToRadians(float in_degrees)
    {
        return in_degrees * ((float)Math.PI / 180.0f);
    }

    public static float WrapToRadians(float in_value)
    {
        float sign = in_value > 0.0f ? 1.0f : -1.0f;
        float mod = (float)Math.Abs(in_value) % 6.28319f;

        return mod * sign;
    }
}
Library "Memory" by "Hyper & Sajid" 
{
    using System.Collections.Generic;
    using System.Runtime.InteropServices;
    using System.Runtime.CompilerServices;
    using System.Text;

    private static Dictionary<nint, List<byte>> _preservedMemory = new();

    public void Preserve(nint in_location, nint in_length, bool in_isPreservedOnce = true)
    {
        if (in_location == 0)
            return;

        if (in_isPreservedOnce)
        {
            if (_preservedMemory.ContainsKey(in_location))
                return;
        }
        else
        {
            if (_preservedMemory.ContainsKey(in_location))
                _preservedMemory.Remove(in_location);
        }
        
        List<byte> buffer = new();
        for (nint i = 0; i < in_length; i++)
            buffer.Add(Read<byte>(in_location + i));

        _preservedMemory.Add(in_location, buffer);
    }

    public void Preserve(long in_location, long in_length, bool in_isPreservedOnce = true)
    {
        Preserve((nint)in_location, (nint)in_length, in_isPreservedOnce);
    }

    public void Restore(nint in_location)
    {
        if (in_location == 0)
            return;

        if (!_preservedMemory.ContainsKey(in_location))
            return;

        nint i = 0;
        foreach (byte b in _preservedMemory[in_location])
        {
            WriteProtected<byte>(in_location + i, b);
            i++;
        }
    }

    public void Restore(long in_location)
    {
        Restore((nint)in_location);
    }

    public nint ReadCall(nint in_location)
    {
        if (in_location == 0)
            return 0;

        return in_location + Read<int>(in_location + 0x01) + 0x05;
    }

    public long ReadCall(long in_location)
    {
        return (long)ReadCall((nint)in_location);
    }

    public nint ReadEffectiveAddress(nint in_location)
    {
        if (in_location == 0)
            return 0;

        return in_location + Read<int>(in_location + 0x03) + 0x07;
    }

    public long ReadEffectiveAddress(long in_location)
    {
        return (long)ReadEffectiveAddress((nint)in_location);
    }

    public enum JumpType : sbyte
    {
        Unknown = -1,
        ShortCond,
        NearJmp,
        NearCond,
        LongJmp
    }

    public JumpType ReadJumpOpcode(nint in_location)
    {
        JumpType result = JumpType.Unknown;

        if (in_location == 0)
            return result;

        byte opcode = Read<byte>(in_location);

        if ((opcode & 0xF0) == 0x70)
        {
            result = JumpType.ShortCond;
        }
        else
        {
            switch (opcode)
            {
                case 0xE3:
                case 0xEB:
                    result = JumpType.ShortCond;
                    break;

                case 0xE9:
                    result = JumpType.NearJmp;
                    break;

                case 0x0F:
                    result = JumpType.NearCond;
                    break;

                case 0xFF:
                    result = JumpType.LongJmp;
                    break;
            }
        }

        return result;
    }

    public JumpType ReadJumpOpcode(long in_location)
    {
        return ReadJumpOpcode((nint)in_location);
    }

    public nint ReadJump(nint in_location)
    {
        if (in_location == 0)
            return 0;

        switch (ReadJumpOpcode(in_location))
        {
            case JumpType.ShortCond:
                return in_location + Read<byte>(in_location + 0x01) + 0x02;

            case JumpType.NearJmp:
                return in_location + Read<int>(in_location + 0x01) + 0x05;

            case JumpType.NearCond:
                return in_location + Read<int>(in_location + 0x02) + 0x06;

            case JumpType.LongJmp:
                return (nint)Read<long>(in_location + 0x06);
        }

        return 0;
    }

    public long ReadJump(long in_location)
    {
        return (long)ReadJump((nint)in_location);
    }

    public void WriteForceJump(nint in_location)
    {
        if (in_location == 0)
            return;
        
        switch (ReadJumpOpcode(in_location))
        {
            case JumpType.ShortCond:
                WriteProtected<byte>(in_location, 0xEB);
                break;

            case JumpType.NearCond:
                WriteProtected<byte>(in_location, 0xE9);
                WriteProtected<int>(in_location + 0x01, Read<int>(in_location + 0x02) + 0x01);
                break;
        }
    }

    public void WriteForceJump(long in_location)
    {
        WriteForceJump((nint)in_location);
    }

    public nint ReadThunk(nint in_location, nint in_offset = 0)
    {
        return ReadJump(ReadCall(in_location) + in_offset);
    }

    public long ReadThunk(long in_location, long in_offset = 0)
    {
        return (long)ReadThunk((nint)in_location, (nint)in_offset);
    }

    public void WriteString(long in_location, string in_str, Encoding in_encoding)
    {
        WriteProtected<byte>(in_location, in_encoding.GetBytes(in_str));
    }

    public void WriteString(long in_location, string in_str)
    {
        WriteString(in_location, in_str, Encoding.ASCII);
    }

    public void PrintMemory<T>(IntPtr in_address, int in_rowCount) where T : unmanaged
    {
        for (int i = 0; i < in_rowCount * 16; i += 16)
        {
            Console.Write($"{(in_address + i).ToInt64():X16}: ");

            if (typeof(T) == typeof(byte) || typeof(T) == typeof(sbyte))
            {
                for (int j = 0; j < 16; j++)
                    Console.Write($"{Read<T>(in_address + i + j):X2} ");
            }
            else if (typeof(T) == typeof(short) || typeof(T) == typeof(ushort))
            {
                for (int j = 0; j < 16; j += 2)
                    Console.Write($"{Read<T>(in_address + i + j):X4} ");
            }
            else if (typeof(T) == typeof(int) || typeof(T) == typeof(uint))
            {
                for (int j = 0; j < 16; j += 4)
                    Console.Write($"{Read<T>(in_address + i + j):X8} ");
            }
            else if (typeof(T) == typeof(long) || typeof(T) == typeof(ulong))
            {
                for (int j = 0; j < 16; j += 8)
                    Console.Write($"{Read<T>(in_address + i + j):X16} ");
            }
            else if (typeof(T) == typeof(float))
            {
                for (int j = 0; j < 16; j += 4)
                    Console.Write($"{Read<float>(in_address + i + j)} ");
            }
            else if (typeof(T) == typeof(double))
            {
                for (int j = 0; j < 16; j += 8)
                    Console.Write($"{Read<double>(in_address + i + j)} ");
            }

            Console.WriteLine();
        }
    }

    public void PrintMemory(IntPtr in_address, int in_rowCount)
    {
        PrintMemory<byte>(in_address, in_rowCount);
    }
    
    public struct Pointer<T> where T : unmanaged
    {
        public T* pData;

        public Pointer(ref T data)
        {
            fixed(T* dataPtr = &data)
            {
                pData = dataPtr;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Pointer(T* in_pData)
        {
            pData = in_pData;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool IsValid()
        {
            return pData != null;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ref T Ref()
        {
            return ref *pData;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public T* Get()
        {
            return pData;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator bool(Pointer<T> self) => self.IsValid();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator Pointer<T>(T* data) => new(data);

        public override string ToString() => $"0x{((long)pData):X}";
    }
}
Library "VectorHelpers" by "Hyper" 
{
    #load "System.Numerics.dll"

    using System.Numerics;

    public static Vector3 ClampMagnitude(Vector3 in_vector, float in_maxMagnitude)
    {
        if (in_vector.Length() > in_maxMagnitude * in_maxMagnitude)
            return Vector3.Normalize(in_vector) * in_maxMagnitude;

        return in_vector;
    }

    public static Vector3 GetForward(Quaternion in_rotation)
    {
        return Vector3.Transform(Vector3.UnitZ, Quaternion.Normalize(in_rotation));
    }

    public static float GetMagnitude(Vector3 in_velocity)
    {
        return in_velocity.Length();
    }

    public static float GetHorizontalMagnitude(Vector3 in_velocity)
    {
        return (float)Math.Sqrt(in_velocity.X * in_velocity.X + in_velocity.Z * in_velocity.Z);
    }

    public static float GetVerticalMagnitude(Vector3 in_velocity)
    {
        return in_velocity.Y;
    }

    public static Quaternion LookRotation(Vector3 in_forward, Vector3 in_upward)
    {
        in_forward = Vector3.Normalize(in_forward);
        in_upward = Vector3.Normalize(in_upward);

        var right = Vector3.Cross(in_upward, in_forward);
        in_upward = Vector3.Cross(in_forward, right);

        var m = new Matrix4x4
        (
            right.X,      right.Y,      right.Z,      0.0f,
            in_upward.X,  in_upward.Y,  in_upward.Z,  0.0f,
            in_forward.X, in_forward.Y, in_forward.Z, 0.0f,
            0.0f,         0.0f,         0.0f,         1.0f
        );

        return Quaternion.CreateFromRotationMatrix(m);
    }

    public static Quaternion LookRotation(Vector3 in_forward)
    {
        return LookRotation(in_forward, Vector3.UnitY);
    }
}
Library "XInput" by "Hyper" 
{
    #lib "MathHelpers"

    #load "System.Numerics.dll"

    using System.Numerics;
    using System.Runtime.InteropServices;

    [DllImport("xinput1_4.dll", EntryPoint = "XInputGetState")]
    public extern int XInputGetState(int in_dwUserIndex, ref State in_pState);
    
    [DllImport("xinput1_4.dll", EntryPoint = "XInputSetState")]
    public extern int XInputSetState(int in_dwUserIndex, ref Vibration in_pVibration);

    public const short XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE = 7849;
    public const short XINPUT_GAMEPAD_RIGHT_THUMB_DEADZONE = 8689;

    private static float _leftMotorSpeed = 0.0f;
    private static float _rightMotorSpeed = 0.0f;

    [Flags]
    public enum Buttons : ushort
    {
        DPAD_UP        = 0x0001,
        DPAD_DOWN      = 0x0002,
        DPAD_LEFT      = 0x0004,
        DPAD_RIGHT     = 0x0008,
        START          = 0x0010,
        BACK           = 0x0020,
        LEFT_THUMB     = 0x0040,
        RIGHT_THUMB    = 0x0080,
        LEFT_SHOULDER  = 0x0100,
        RIGHT_SHOULDER = 0x0200,
        A              = 0x1000,
        B              = 0x2000,
        X              = 0x4000,
        Y              = 0x8000
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct State
    {
        public int dwPacketNumber;
        public Gamepad Gamepad;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct Gamepad
    {
        public Buttons wButtons;
        public byte bLeftTrigger;
        public byte bRightTrigger;
        public short sThumbLX;
        public short sThumbLY;
        public short sThumbRX;
        public short sThumbRY;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct Vibration
    {
        public ushort wLeftMotorSpeed;
        public ushort wRightMotorSpeed;

        public Vibration(ushort in_leftMotorSpeed, ushort in_rightMotorSpeed)
        {
            wLeftMotorSpeed = in_leftMotorSpeed;
            wRightMotorSpeed = in_rightMotorSpeed;

            _leftMotorSpeed = in_leftMotorSpeed / 65535.0f;
            _rightMotorSpeed = in_rightMotorSpeed / 65535.0f;
        }

        public Vibration(float in_leftMotorSpeed, float in_rightMotorSpeed)
        {
            wLeftMotorSpeed = MathHelpers.FloatPercentToRange<ushort>(in_leftMotorSpeed);
            wRightMotorSpeed = MathHelpers.FloatPercentToRange<ushort>(in_rightMotorSpeed);

            _leftMotorSpeed = in_leftMotorSpeed;
            _rightMotorSpeed = in_rightMotorSpeed;
        }

        public Vibration(ushort in_motorSpeed)
        {
            wLeftMotorSpeed = wRightMotorSpeed = in_motorSpeed;
            _leftMotorSpeed = _rightMotorSpeed = in_motorSpeed / 65535.0f;
        }

        public Vibration(float in_motorSpeed)
        {
            wLeftMotorSpeed = wRightMotorSpeed = MathHelpers.FloatPercentToRange<ushort>(in_motorSpeed);
            _leftMotorSpeed = _rightMotorSpeed = in_motorSpeed;
        }
    }

    public State? GetState()
    {
        var pState = new State();

        if (XInputGetState(0, ref pState) != 0)
            return null;

        return pState;
    }

    public void SetState(Vibration in_vibration)
    {
        XInputSetState(0, ref in_vibration);
    }

    public Vector2 GetAnalog(int in_analogIndex, bool in_isTestDeadzone = true)
    {
        var pState = GetState();

        if (pState == null)
            return Vector2.Zero;

        Vector2 v = Vector2.Zero;

        switch (in_analogIndex)
        {
            case 0:
                v = new Vector2(pState.Value.Gamepad.sThumbLX / 32767.0f, pState.Value.Gamepad.sThumbLY / 32767.0f);
                break;

            case 1:
                v = new Vector2(pState.Value.Gamepad.sThumbRX / 32767.0f, pState.Value.Gamepad.sThumbRY / 32767.0f);
                break;
        }

        if (in_isTestDeadzone)
        {
            v = IsAnalogNeutral(in_analogIndex)
                ? Vector2.Zero
                : v;
        }

        return v;
    }

    // Use Player.Input for keyboard parity!
    public bool IsButtonDown(Buttons in_buttons)
    {
        var pState = GetState();

        if (pState == null)
            return false;

        return (pState.Value.Gamepad.wButtons & in_buttons) != 0;
    }

    public float GetTrigger(int in_triggerIndex)
    {
        var pState = GetState();

        if (pState == null)
            return 0;

        switch (in_triggerIndex)
        {
            case 0:
                return pState.Value.Gamepad.bLeftTrigger / 255.0f;

            case 1:
                return pState.Value.Gamepad.bRightTrigger / 255.0f;
        }

        return 0;
    }

    public bool IsAnalogNeutral(int in_analogIndex)
    {
        var pState = GetState();

        if (pState == null)
            return true;

        switch (in_analogIndex)
        {
            case 0:
            {
                short x = pState.Value.Gamepad.sThumbLX;
                short y = pState.Value.Gamepad.sThumbLY;

                return x < XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE &&
                    x > -XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE &&
                    y < XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE &&
                    y > -XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE;
            }

            case 1:
            {
                short x = pState.Value.Gamepad.sThumbRX;
                short y = pState.Value.Gamepad.sThumbRY;

                return x < XINPUT_GAMEPAD_RIGHT_THUMB_DEADZONE &&
                    x > -XINPUT_GAMEPAD_RIGHT_THUMB_DEADZONE &&
                    y < XINPUT_GAMEPAD_RIGHT_THUMB_DEADZONE &&
                    y > -XINPUT_GAMEPAD_RIGHT_THUMB_DEADZONE;
            }
        }

        return true;
    }

    public Vibration GetVibration()
    {
        return new Vibration(_leftMotorSpeed, _rightMotorSpeed);
    }

    public void SetVibration(float in_value)
    {
        SetState(new Vibration(in_value));
    }

    public void SetVibration(int in_motorIndex, float in_value)
    {
        switch (in_motorIndex)
        {
            case 0:
            {
                SetState(new Vibration(in_value, _rightMotorSpeed));
                break;
            }

            case 1:
            {
                SetState(new Vibration(_leftMotorSpeed, in_value));
                break;
            }
        }
    }
}



Patch "Disable Tails Commentary" in "Audio" by "Hyper" 
WriteProtected<byte>(ScanSignature("\x48\x8B\xC4\x57\x41\x54\x41\x55\x41\x56\x41\x57\x48\x83\xEC\x60\x48\xC7\x40\x00\x00\x00\x00\x00\x48\x89\x58\x10\x48\x89\x68\x18\x48\x89\x70\x20\x4D\x63\xE0\x48\x8B\xE9\x44\x3B\xA1\x00\x00\x00\x00\x0F\x84\x00\x00\x00\x00\x48\x8B\xCA\xE8\x00\x00\x00\x00\x48\x8B\xD8\x48\x85\xC0\x0F\x84\x00\x00\x00\x00\x48\x8D\x48\x08\x8B\x15\x00\x00\x00\x00\xE8\x00\x00\x00\x00\x4C\x8B\xF8\x48\x85\xC0\x0F\x84\x00\x00\x00\x00\x48\x8B\x4B\x48\x48\x89\x4C\x24\x00\x48\x8B\x4B\x50\x48\x89\x4C\x24\x00\x48\x85\xC9\x74\x04\xF0\xFF\x41\x08\xBF\x00\x00\x00\x00\x4C\x8D\x2D\x00\x00\x00\x00\x83\xBD\x00\x00\x00\x00\x00\x74\x31\x33\xDB\x8B\xF7\x66\x0F\x1F\x44\x00\x00\x44\x8B\x85\x00\x00\x00\x00\x4C\x03\xC3\x4F\x8B\x44\xC5\x00\x48\x8D\x54\x24\x00\x49\x8D\x4F\x60\xE8\x00\x00\x00\x00\x48\x83\xC3\x06\x48\x83\xEE\x01\x75\xD9\x4A\x8D\x1C\xE5\x00\x00\x00\x00\x49\x03\xDD\x41\xB0\x01\xBA\x00\x00\x00\x00\x48\x8D\x4C\x24\x00\xE8\x00\x00\x00\x00\x48\x8D\x44\x24\x00\x48\x89\x44\x24\x00\x4C\x8B\x0B\x4C\x8D\x44\x24\x00\x48\x8D\x94\x24\x00\x00\x00\x00\x49\x8D\x4F\x60\xE8\x00\x00\x00\x00\x48\x8B\x8C\x24\x00\x00\x00\x00\x48\x85\xC9\x74\x10\x83\x41\x08\xFF\x75\x0A\x48\x8B\x01\xBA\x00\x00\x00\x00\xFF\x10\x48\x83\xC3\x30\x48\x83\xEF\x01\x75\xA4\x48\x8B\x5C\x24\x00\x48\x85\xDB\x74\x2E\xBF\x00\x00\x00\x00\x8B\xC7\xF0\x0F\xC1\x43\x00\x83\xF8\x01\x75\x1D\x48\x8B\x03\x48\x8B\xCB\xFF\x50\x08\xF0\x0F\xC1\x7B\x00\x83\xFF\x01\x75\x0A\x48\x8B\x03\x48\x8B\xCB\xFF\x50\x10\x90\x44\x89\xA5\x00\x00\x00\x00\x4C\x8D\x5C\x24\x00\x49\x8B\x5B\x38\x49\x8B\x6B\x40\x49\x8B\x73\x48\x49\x8B\xE3\x41\x5F\x41\x5E\x41\x5D\x41\x5C\x5F\xC3", "xxxxxxxxxxxxxxxxxxx?????xxxxxxxxxxxxxxxxxxxxx????xx????xxxx????xxxxxxxx????xxxxxx????x????xxxxxxxx????xxxxxxxx?xxxxxxxx?xxxxxxxxxx????xxx????xx?????xxxxxxxxxxx?xxx????xxxxxxx?xxxx?xxxxx????xxxxxxxxxxxxxx????xxxxxxx????xxxx?x????xxxx?xxxx?xxxxxxx?xxxx????xxxxx????xxxx????xxxxxxxxxxxxxxx????xxxxxxxxxxxxxxxx?xxxxxx????xxxxxx?xxxxxxxxxxxxxxxxxx?xxxxxxxxxxxxxxxxxx????xxxx?xxxxxxxxxxxxxxxxxxxxxxxxx") + 0x82, 0x02);



Patch "Disable Boost Drain" in "Cheats" by "SuperSonic16" 
WriteNop(ScanSignature("\x40\x53\x48\x83\xEC\x60\x48\xC7\x44\x24\x00\x00\x00\x00\x00\x0F\x29\x74\x24\x00\x0F\x28\xF1\x48\x8B\xD9\xE8\x00\x00\x00\x00\x84\xC0\x74\x32\x0F\x28\xD6\xBA\x00\x00\x00\x00\x48\x8D\x4C\x24\x00\xE8\x00\x00\x00\x00\x90\x48\x8D\x54\x24\x00\x48\x8B\xCB\xE8\x00\x00\x00\x00\x90\xF3\x0F\x10\x44\x24\x00\x0F\x28\x74\x24\x00\x48\x83\xC4\x60\x5B\xC3\x48\x8B\xCB\xE8\x00\x00\x00\x00\x48\x8B\xC8\xE8\x00\x00\x00\x00\x48\x8B\xD8\x0F\x28\xCE\x48\x8B\xC8\xE8\x00\x00\x00\x00\xF3\x0F\x10\x43\x00\x0F\x28\x74\x24\x00\x48\x83\xC4\x60\x5B\xC3", "xxxxxxxxxx?????xxxx?xxxxxxx????xxxxxxxx????xxxx?x????xxxxx?xxxx????xxxxxx?xxxx?xxxxxxxxxx????xxxx????xxxxxxxxxx????xxxx?xxxx?xxxxxx") + 0x60, 5); // 1417EBA70 (1.09)



Patch "Disable Damage" in "Cheats" by "SuperSonic16" 
WriteProtected<byte>(ScanSignature("\x48\x8B\xC4\x57\x48\x81\xEC\x00\x00\x00\x00\x48\xC7\x44\x24\x00\x00\x00\x00\x00\x48\x89\x58\x08\x0F\x29\x70\xE8\x49\x8B\xF8\x48\x8B\xDA\x49\x8B\x40\x40\x48\x85\xC0\x74\x10\x83\x78\x3C\x03\x74\x0A\x41\xC6\x40\x00\x00\xE9\x00\x00\x00\x00\x48\x8B\xCB\xE8\x00\x00\x00\x00\x84\xC0\x0F\x85\x00\x00\x00\x00\x48\x8B\xCB\xE8\x00\x00\x00\x00\x84\xC0\x0F\x85\x00\x00\x00\x00\xBA\x00\x00\x00\x00\x48\x8B\xCB\xE8\x00\x00\x00\x00\x84\xC0\x0F\x85\x00\x00\x00\x00\x48\x8B\xCB\xE8\x00\x00\x00\x00\x84\xC0\x0F\x85\x00\x00\x00\x00\x48\x8B\xCB\xE8\x00\x00\x00\x00\x8B\x48\x14\x3B\x4F\x20\x0F\x8D\x00\x00\x00\x00\x48\x8B\xCB", "xxxxxxx????xxxx?????xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx??x????xxxx????xxxx????xxxx????xxxx????x????xxxx????xxxx????xxxx????xxxx????xxxx????xxxxxxxx????xxx"), 0xC3); // 1418ADFA0 (1.09)



Patch "Disable Super Sonic Ring Drain" in "Cheats" by "SuperSonic16" 
WriteNop(ScanSignature("\x40\x57\x48\x83\xEC\x60\x48\xC7\x44\x24\x00\x00\x00\x00\x00\x48\x89\x5C\x24\x00\x48\x89\x74\x24\x00\x0F\x29\x74\x24\x00\x0F\x28\xF2\x48\x8B\xFA\x48\x8B\xD9\xF6\x41\x28\x05\x75\x3E\xF3\x0F\x10\x49\x00\xF3\x0F\x5C\xCE\xF3\x0F\x11\x49\x00\x0F\x57\xC0\x0F\x2F\xC8\x77\x28\x41\xB0\x01\xBA\x00\x00\x00\x00\x48\x8B\xCF\xE8\x00\x00\x00\x00\xF3\x0F\x10\x43\x00\xF3\x0F\x10\x0D\x00\x00\x00\x00\xF3\x0F\x58\xC1\xF3\x0F\x11\x43\x00\xEB\x08\xF3\x0F\x10\x0D\x00\x00\x00\x00\xF3\x0F\x58\x73", "xxxxxxxxxx?????xxxx?xxxx?xxxx?xxxxxxxxxxxxxxxxxxx?xxxxxxxx?xxxxxxxxxxxx????xxxx????xxxx?xxxx????xxxxxxxx?xxxxxx????xxxx") + 0x4E, 5); // 1418FE750 (1.09)



Patch "Enable Super Sonic with 1 Ring" in "Cheats" by "SuperSonic16" 
WriteProtected<byte>(ScanSignature("\xB8\x00\x00\x00\x00\x2B\xC2\x41\x39\x86\x00\x00\x00\x00\x7C\x2A\x41\x83\xBE\x00\x00\x00\x00\x00\x75\x52\x45\x33\xC0\x41\x8D\x50\x09\x48\x8D\x4D\x97\xE8\x00\x00\x00\x00\x90\x48\x8D\x55\x97\x49\x8B\xCE\xE8\x00\x00\x00\x00\x90\xEB\x32\x41\x80\xBE\x00\x00\x00\x00\x00\x75\x28\x41\x83\xBE\x00\x00\x00\x00\x00\x74\x1E\x45\x33\xC0\x41\x8D\x50\xFF\x48\x8D\x4D\x97\xE8\x00\x00\x00\x00\x90\x48\x8D\x55\x97\x49\x8B\xCE\xE8\x00\x00\x00\x00\x90\x4C\x8D\x9C\x24\x00\x00\x00\x00\x49\x8B\x5B\x38\x49\x8B\x73\x40\x49\x8B\x7B\x48\x49\x8B\xE3\x41\x5F\x41\x5E\x41\x5D\x41\x5C\x5D\xC3", "x????xxxxx????xxxxx?????xxxxxxxxxxxxxx????xxxxxxxxx????xxxxxx?????xxxxx?????xxxxxxxxxxxxxx????xxxxxxxxx????xxxxx????xxxxxxxxxxxxxxxxxxxxxxxxx") + 0x01, 0x01); // 14198AD0B (1.09)
WriteProtected<byte>(ScanSignature("\xBD\x00\x00\x00\x00\xF6\x41\x20\x01\x75\x6A\x48\x8B\xCA\xE8\x00\x00\x00\x00\x84\xC0\x75\x5E\x48\x8B\xCE\xE8\x00\x00\x00\x00\x8B\xD8\xE8\x00\x00\x00\x00\x0F\xB6\x88\x00\x00\x00\x00\x8D\x14\x49\xC1\xE2\x04\x8B\xCD\x2B\xCA\x3B\xD9\x7C\x3A\x48\x8B\xCE\xE8\x00\x00\x00\x00\x84\xC0\x75\x2E\xE8\x00\x00\x00\x00\x80\xB8\x00\x00\x00\x00\x00\x75\x0F\x8D\x55\xD6\x48\x8B\xCE\xE8\x00\x00\x00\x00\x84\xC0\x74\x11\xBA\x00\x00\x00\x00\x48\x8B\xCE\xE8\x00\x00\x00\x00\x83\x4F\x1C\x01\xF6\x47\x20\x01\x0F\x85\x00\x00\x00\x00\x48\x8B\xCE\xE8\x00\x00\x00\x00\x84\xC0", "x????xxxxxxxxxx????xxxxxxxx????xxx????xxx????xxxxxxxxxxxxxxxxxx????xxxxx????xx?????xxxxxxxxx????xxxxx????xxxx????xxxxxxxxxx????xxxx????xx") + 0x01, 0x01); // 1418FE3F4 (1.09)



Patch "Disable Hint Rings" in "Gameplay" by "Hyper" 
WriteProtected<byte>(ScanSignature("\x40\x55\x56\x57\x41\x54\x41\x55\x41\x56\x41\x57\x48\x8D\xAC\x24\x00\x00\x00\x00\x48\x81\xEC\x00\x00\x00\x00\x48\xC7\x45\x00\x00\x00\x00\x00\x48\x89\x9C\x24\x00\x00\x00\x00\x4C\x8B\xEA\x48\x8B\xD9\x4C\x8D\xB9\x00\x00\x00\x00\xC7\x45\x00\x00\x00\x00\x00\x41\x0F\x10\x57\x00\xF2\x41\x0F\x10\x47\x00\xF2\x0F\x11\x45\x00\x66\x0F\x6F\xCA\x66\x0F\x73\xD9\x00\x66\x0F\x7E\xC8\x48\x63\xC8\x48\x03\xCB\x4C\x8D\x45\xD8\x48\x8D\x55\x40\x66\x48\x0F\x7E\xD0\xFF\xD0\xE8\x00\x00\x00\x00\x8D\x48\xFF\x83\xF9\x02\x77\x27\x80\xBB\x00\x00\x00\x00\x00\x74\x1E\xFF\xC8\x89\x83\x00\x00\x00\x00\x83\xBC\x83\x00\x00\x00\x00\x00\x75\x0C\xC6\x83\x00\x00\x00\x00\x00\xE9\x00\x00\x00\x00\x48\x8D\x15\x00\x00\x00\x00\x49\x8B\xCD\xE8\x00\x00\x00\x00\x4C\x8B\xF0\x45\x33\xE4\x41\x8D\x74\x24\x00\x48\x85\xC0\x0F\x84\x00\x00\x00\x00\x4C\x89\xA5\x00\x00\x00\x00\x4C\x39\x60\x18\x74\x21\x48\x8D\x8D\x00\x00\x00\x00\xE8\x00\x00\x00\x00\x49\x8B\x4E\x18\x48\x89\x8D\x00\x00\x00\x00\x48\x85\xC9\x74\x05\xE8\x00\x00\x00\x00\x45\x33\xC0\x48\x8D\x95\x00\x00\x00\x00\x48\x8D\x4D\xE8\xE8\x00\x00\x00\x00\x90\x4C\x8D\xA3\x00\x00\x00\x00\x48\x8B\x08\x49\x89\x0C\x24\x48\x8D\x50\x08\x49\x8D\x4C\x24\x00\xE8\x00\x00\x00\x00\x90\x48\x8B\x7D\xF0\x48\x85\xFF\x74\x2B\x8B\xC6\xF0\x0F\xC1\x47\x00\x83\xF8\x01\x75\x1F\x48\x8B\x07\x48\x8B\xCF\xFF\x50\x08\x8B\xC6\xF0\x0F\xC1\x47\x00\x83\xF8\x01\x75\x0A\x48\x8B\x07\x48\x8B\xCF\xFF\x50\x10\x90", "xxxxxxxxxxxxxxxx????xxx????xxx?????xxxx????xxxxxxxxx????xx?????xxxx?xxxxx?xxxx?xxxxxxxx?xxxxxxxxxxxxxxxxxxxxxxxxxx????xxxxxxxxxx?????xxxxxx????xxx?????xxxx?????x????xxx????xxxx????xxxxxxxxxx?xxxxx????xxx????xxxxxxxxx????x????xxxxxxx????xxxxxx????xxxxxx????xxxxx????xxxx????xxxxxxxxxxxxxxx?x????xxxxxxxxxxxxxxxx?xxxxxxxxxxxxxxxxxxxx?xxxxxxxxxxxxxxx"), 0xC3);



Patch "Disable Tails Save" in "Gameplay" by "Hyper" 
WriteProtected<byte>(ScanSignature(
    "\x48\x89\x5C\x24\x00\x48\x89\x74\x24\x00\x57\x48\x83\xEC\x30\x48\x89\xD3\x0F\x29\x74\x24\x00\x8B\x15\x00\x00\x00\x00\x81\xF2\x00\x00\x00\x00\x41\x0F\xB6\xF9\x0F\x28\xF2\x48\x89\xCE\xE8\x00\x00\x00\x00\x48\x8D\x05\x00\x00\x00\x00\x48\x89\x06\x8B\x03\x89\x46\x18\x8B\x43\x04\x89\x46\x1C\x8B\x43\x08\x48\x8B\x5C\x24\x00\x89\x46\x20\x0F\xB6\x44\x24\x00\x88\x46\x29\x8B\x44\x24\x68\x89\x46\x2C\x48\x89\xF0\xF3\x0F\x11\x76\x00\x0F\x28\x74\x24\x00\x40\x88\x7E\x28\x48\x8B\x74\x24\x00\x48\x83\xC4\x30\x5F\xC3\xCC\x4C\x8B\x1C\x24\x48\x83\xC4\x08\xE9\x00\x00\x00\x00", "xxxx?xxxx?xxxxxxxxxxxx?xx????xx????xxxxxxxxxxx????xxx????xxxxxxxxxxxxxxxxxxxxx?xxxxxxx?xxxxxxxxxxxxxxxxx?xxxx?xxxxxxxx?xxxxxxxxxxxxxxxx????",
    "\x48\x89\x5C\x24\x00\x48\x89\x74\x24\x00\x57\x48\x83\xEC\x30\x48\x89\xD3\x0F\x29\x74\x24\x00\xBA\x00\x00\x00\x00\x41\x0F\xB6\xF9\x0F\x28\xF2\x48\x89\xCE\xE8\x00\x00\x00\x00\x48\x8D\x05\x00\x00\x00\x00\x48\x89\x06\x8B\x03\x89\x46\x18\x8B\x43\x04\x89\x46\x1C\x8B\x43\x08\x48\x8B\x5C\x24\x00\x89\x46\x20\x0F\xB6\x44\x24\x00\x88\x46\x29\x8B\x44\x24\x68\x89\x46\x2C\x48\x89\xF0\xF3\x0F\x11\x76\x00\x0F\x28\x74\x24\x00\x40\x88\x7E\x28\x48\x8B\x74\x24\x00\x48\x83\xC4\x30\x5F\xC3\xCC\x4C\x8B\x24\x24\x48\x8D\x64\x24\x00\x48\x8B\x04\x24\x48\x8D\x64\x24\x00\xE9\x00\x00\x00\x00\x4C\x8B\x1C\x24\x48\x8D\x64\x24\x00\xE9\x00\x00\x00\x00", "xxxx?xxxx?xxxxxxxxxxxx?x????xxxxxxxxxxx????xxx????xxxxxxxxxxxxxxxxxxxxx?xxxxxxx?xxxxxxxxxxxxxxxxx?xxxx?xxxxxxxx?xxxxxxxxxxxxxxx?xxxxxxxx?x????xxxxxxxx?x????",
    "\x48\x89\x5C\x24\x00\x48\x89\x74\x24\x00\x57\x48\x83\xEC\x30\x48\x89\xD3\x0F\x29\x74\x24\x00\xBA\x00\x00\x00\x00\x41\x0F\xB6\xF9\x0F\x28\xF2\x48\x89\xCE\xE8\x00\x00\x00\x00\x48\x8D\x05\x00\x00\x00\x00\x48\x89\x06\x8B\x03\x89\x46\x18\x8B\x43\x04\x89\x46\x1C\x8B\x43\x08\x48\x8B\x5C\x24\x00\x89\x46\x20\x0F\xB6\x44\x24\x00\x88\x46\x29\x8B\x44\x24\x68\x89\x46\x2C\x48\x89\xF0\xF3\x0F\x11\x76\x00\x0F\x28\x74\x24\x00\x40\x88\x7E\x28\x48\x8B\x74\x24\x00\x48\x83\xC4\x30\x5F\xC3", "xxxx?xxxx?xxxxxxxxxxxx?x????xxxxxxxxxxx????xxx????xxxxxxxxxxxxxxxxxxxxx?xxxxxxx?xxxxxxxxxxxxxxxxx?xxxx?xxxxxxxx?xxxxxx"), 0xC3);



Patch "Always Run in the Background" in "System" by "Labrys" 
WriteProtected<byte>(ScanSignature("\xC6\x81\xB6\x32\x00\x00\x00", "xxxxxxx") + 0x06, 0x01);
// 1401044C7 (1.09)


